<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responder Dashboard - LSPU Emergency Response System</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/responder-dashboard.css">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet Routing Machine CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3b82f6">
    <!-- Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="js/supabase.js"></script>
    <style>
        /* Notification Toast Animations */
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-logo">
                    <img src="images/udrrmo image.jpg" alt="UDRRMO Logo" 
                         style="width: 50px; height: 50px; object-fit: contain; border-radius: 50%; border: 2px solid white; display: block;">
                    <div class="sidebar-title">
                        <h2>Responder Dashboard</h2>
                        <p>Emergency Response</p>
                </div>
                </div>
            </div>
            
            <div class="system-status">
                <div class="status-indicator">
                    <span class="status-dot online" id="statusDot"></span>
                    <span id="statusText">System Status: Online</span>
            </div>
        </div>

            <nav class="sidebar-nav">
                <button onclick="showSection('dashboard')" class="nav-item active" id="nav-dashboard">
                    <i class="bi bi-house"></i> Dashboard
                </button>
                <button onclick="showSection('assignments')" class="nav-item" id="nav-assignments">
                    <i class="bi bi-clipboard-check"></i> My Assignments
                </button>
                <button onclick="showSection('map')" class="nav-item" id="nav-map">
                    <i class="bi bi-map"></i> Map View
                </button>
            </nav>
            
            <div class="sidebar-footer">
                <div class="user-info-card">
                    <div class="user-avatar" id="userAvatar">R</div>
                    <div class="user-details">
                        <h4 id="userName">Demo Responder</h4>
                        <p id="userRole">Emergency Responder</p>
                    </div>
                </div>
                <button class="logout-btn" onclick="logout()">
                    <i class="bi bi-box-arrow-right"></i> Logout
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Alerts Container -->
        <div class="alerts-container"></div>

            <!-- Dashboard Section -->
            <div id="dashboard-section" class="admin-section active">
                <!-- Dashboard Header -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Responder Dashboard</h2>
                        <p class="card-subtitle">Emergency response management and assignment tracking</p>
            </div>
                </div>
                
                <!-- Statistics Cards -->
                <div class="stats-grid">
                    <div class="stat-card stat-card-blue">
                        <div class="stat-icon">
                            <i class="bi bi-clipboard-check"></i>
                </div>
                        <div class="stat-content">
                            <div class="stat-number" id="assignedReports">0</div>
                            <div class="stat-label">Assigned Reports</div>
                            <div class="stat-trend" id="assignedTrend">Loading...</div>
                </div>
            </div>
                    
                    <div class="stat-card stat-card-green">
                        <div class="stat-icon">
                            <i class="bi bi-check-circle"></i>
                </div>
                        <div class="stat-content">
                            <div class="stat-number" id="completedReports">0</div>
                            <div class="stat-label">Completed</div>
                            <div class="stat-trend" id="completedTrend">Loading...</div>
                </div>
            </div>
                    
                    <div class="stat-card stat-card-purple">
                        <div class="stat-icon">
                            <i class="bi bi-clock"></i>
                </div>
                        <div class="stat-content">
                            <div class="stat-number" id="avgResponseTime">--</div>
                            <div class="stat-label">Avg Response Time</div>
                            <div class="stat-trend" id="responseTrend">Loading...</div>
                </div>
            </div>
                    
                    <div class="stat-card stat-card-orange">
                        <div class="stat-icon">
                            <i class="bi bi-geo-alt"></i>
                </div>
                        <div class="stat-content">
                            <div class="stat-number" id="coverageRadius">5km</div>
                            <div class="stat-label">Coverage Radius</div>
                            <div class="stat-trend" id="coverageTrend">Active</div>
                </div>
            </div>
                </div>
                
                <!-- Dashboard Cards Row -->
                <div class="dashboard-cards-row">
                <!-- Recent Assignments -->
                    <div class="card dashboard-card">
                    <div class="card-header">
                            <h3 class="card-title">My Assignments</h3>
                    </div>
                    <div class="card-body">
                        <div id="recentAssignments">
                            <div class="loading-spinner"></div>
                            <p>Loading assignments...</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Completed Assignments -->
                    <div class="card dashboard-card">
                        <div class="card-header">
                            <h3 class="card-title">Completed Assignments</h3>
                        </div>
                        <div class="card-body">
                            <div id="completedAssignments">
                                <div class="loading-spinner"></div>
                                <p>Loading completed assignments...</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Responder Status -->
                    <div class="card dashboard-card status-card">
                        <div class="card-header">
                            <h3 class="card-title">My Status</h3>
                            <p class="card-subtitle">Manage your availability and status</p>
                        </div>
                        <div class="card-body">
                            <div class="status-content">
                                <div class="status-toggle">
                                    <span class="status-toggle-label">Availability Status</span>
                                    <div class="status-toggle-switch" id="availabilityToggle" onclick="toggleAvailability()"></div>
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">Current Status</label>
                                    <div class="form-control" id="currentStatus">Available</div>
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">Last Updated</label>
                                    <div class="form-control" id="lastUpdated">Just now</div>
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">Response Statistics</label>
                                    <div class="form-control">
                                        <div class="d-flex justify-content-between">
                                            <span>Total Assignments:</span>
                                            <span id="totalAssignments">0</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>Completed:</span>
                                            <span id="totalCompleted">0</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>Success Rate:</span>
                                            <span id="successRate">0%</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>Active Assignments:</span>
                                            <span id="activeAssignments">0</span>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <span>Avg Response Time:</span>
                                            <span id="avgResponseTime">--</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                                </div>
                            </div>
                                </div>
                            </div>

            <!-- Assignments Section -->
            <div id="assignments-section" class="admin-section">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">üìã My Emergency Assignments</h3>
                        <p class="card-subtitle">Manage your assigned emergency reports</p>
                        </div>
                    <div class="card-body">
                        <div class="emergency-list" id="assignmentsList">
                            <div class="loading-spinner"></div>
                            <p>Loading assignments...</p>
                    </div>
                    </div>
            </div>

                <!-- Assignment Details -->
                <div class="card" id="assignmentDetails" style="display: none;">
                    <div class="card-header">
                        <h3 class="card-title">üìÑ Assignment Details</h3>
                    </div>
                    <div class="card-body" id="assignmentDetailsContent">
                        <!-- Assignment details will be populated here -->
                    </div>
                </div>
                            </div>
                            

            <!-- Map Section -->
            <div id="map-section" class="admin-section">
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">üó∫Ô∏è Emergency Map & Navigation</h3>
                        <p class="card-subtitle">View emergency locations, navigate to assignments, and track your position</p>
                </div>
                    <div class="card-body">
                        <div class="map-navigation-container">
                            <div class="map-container" id="map"></div>
                            
                            <!-- Real-World Navigation Panel -->
                            <div class="real-world-navigation-panel" id="realWorldNavigation" style="display: none;">
                                <div class="navigation-header">
                                    <h4 class="navigation-title">üó∫Ô∏è Real-World Navigation</h4>
                                    <button class="navigation-close" onclick="closeRealWorldNavigation()">√ó</button>
                                </div>
                                <div class="navigation-body">
                                    <div id="realWorldNavigationContent">
                                        <div class="text-center py-4">
                                            <i class="bi bi-navigation text-3xl text-muted mb-3"></i>
                                            <p class="text-muted">Select an assignment to start navigation</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Navigation Controls -->
                        <div class="navigation-controls-panel" id="navigationControls" style="display: none;">
                            <div class="card" style="margin-top: 20px;">
                                <div class="card-header">
                                    <h4 class="card-title">üß≠ Active Navigation</h4>
                                </div>
                                <div class="card-body">
                                    <div id="navigationContent">
                                        <div class="text-center py-4">
                                            <i class="bi bi-navigation text-3xl text-muted mb-3"></i>
                                            <p class="text-muted">Select an assignment to start navigation</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                </div>

        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Routing Machine -->
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <!-- OpenRouteService for real routing -->
    <script>
        // Responder Dashboard JavaScript
        let currentReports = [];
        let notificationChannel = null;
        let responderMap = null;
        let routingControl = null;
        let responderNavigationRoute = null;
        let responderId = null;
        let isAvailable = true;
        let currentLocation = null;

        // Open Field coordinates (walkable area)
        const OPEN_FIELD_CENTER = [14.262689, 121.398464];
        const OPEN_FIELD_RADIUS = 100; // meters

        // Check if a coordinate is near the Open Field
        function isNearOpenField(lat, lng) {
            const distance = L.latLng(lat, lng).distanceTo(L.latLng(OPEN_FIELD_CENTER[0], OPEN_FIELD_CENTER[1]));
            return distance < OPEN_FIELD_RADIUS;
        }

        // Create a direct route through the open field (walkable area)
        function createDirectFieldRoute(from, to) {
            const distance = from.distanceTo(to);
            const numSegments = Math.max(3, Math.min(20, Math.ceil(distance / 20))); // 3-20 segments
            
            const route = [from];
            
            for (let i = 1; i < numSegments; i++) {
                const ratio = i / numSegments;
                const lat = from.lat + (to.lat - from.lat) * ratio;
                const lng = from.lng + (to.lng - from.lng) * ratio;
                route.push(L.latLng(lat, lng));
            }
            
            route.push(to);
            return route;
        }

        // Check if route should go directly through Open Field
        function shouldUseDirectFieldRoute(from, to) {
            return isNearOpenField(from.lat, from.lng) && isNearOpenField(to.lat, to.lng);
        }

        // Initialize real-world routing
        function initializeRealRouting() {
            console.log('üó∫Ô∏è Initializing real-world routing...');
            
            // Configure routing with real road data
            L.Routing.control({
                waypoints: [],
                routeWhileDragging: true,
                addWaypoints: false,
                createMarker: function(i, waypoint, n) {
                    const marker = L.marker(waypoint.latLng, {
                        icon: L.divIcon({
                            className: 'routing-marker',
                            html: `<div style="background: ${i === 0 ? '#3b82f6' : '#ef4444'}; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${i === 0 ? 'üöó' : 'üéØ'}</div>`,
                            iconSize: [30, 30],
                            iconAnchor: [15, 15]
                        })
                    });
                    
                    if (i === 0) {
                        marker.bindPopup(`
                            <div style="min-width: 200px;">
                                <h4 style="margin: 0 0 10px 0; color: #3b82f6;">üöó Your Location</h4>
                                <p><strong>Status:</strong> Starting point</p>
                                <p><strong>Accuracy:</strong> High precision</p>
                            </div>
                        `);
                    } else {
                        marker.bindPopup(`
                            <div style="min-width: 200px;">
                                <h4 style="margin: 0 0 10px 0; color: #ef4444;">üéØ Emergency Location</h4>
                                <p><strong>Status:</strong> Destination</p>
                                <p><strong>Priority:</strong> High</p>
                            </div>
                        `);
                    }
                    
                    return marker;
                },
                lineOptions: {
                    styles: [
                        {color: '#10b981', weight: 6, opacity: 0.9}
                    ]
                },
                show: false, // Hide default routing control
                router: L.Routing.osrmv1({
                    serviceUrl: 'https://routing.openstreetmap.de/routed-foot/route/v1',
                    profile: 'foot'
                })
            });
            
            console.log('‚úÖ Real-world routing initialized');
        }

        // Initialize the system when the page loads
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                console.log('üöÄ Initializing responder dashboard...');
                
                // Wait for system initialization with longer timeout
                await new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 100; // Increased from 50 to 100
                    
                    const checkInit = () => {
                        attempts++;
                        if (window.emergencySystem && window.emergencySystem.isInitialized) {
                            console.log('‚úÖ System initialization detected');
                            resolve();
                        } else if (attempts >= maxAttempts) {
                            console.error('‚ùå System initialization timeout after', attempts, 'attempts');
                            reject(new Error('System initialization timeout'));
                        } else {
                            setTimeout(checkInit, 200); // Increased from 100ms to 200ms
                        }
                    };
                    checkInit();
                });

                // Check user role
                if (!checkUserRole()) {
                    return;
                }

                // Get responder ID
                await getResponderId();

                // Load dashboard data
                await loadDashboardData();
                
                // Initialize map with delay to ensure DOM is ready
                setTimeout(() => {
                initializeMap();
                }, 500);
                
                // Set up real-time notifications
                await setupNotifications();
                
                // Initialize location tracking
                initializeLocationTracking();
                
                // Set up periodic refresh of other responders (every 30 seconds)
                setInterval(async () => {
                    if (responderMap && responderId) {
                        await loadOtherResponders();
                    }
                }, 30000);
                
                // Update user info
                updateUserInfo();
                
                console.log('‚úÖ Responder dashboard initialized successfully');
            } catch (error) {
                console.error('‚ùå Error initializing responder dashboard:', error);
                
                // Show user-friendly error message
                const alertsContainer = document.querySelector('.alerts-container');
                if (alertsContainer) {
                    alertsContainer.innerHTML = `
                        <div class="alert alert-error">
                            <strong>Dashboard Initialization Error</strong><br>
                            Some features may not work properly. Please refresh the page or contact support.
                        </div>
                    `;
                }
                
                // Try to continue with basic functionality
                try {
                    await loadDashboardData();
                    initializeMap();
                    updateUserInfo();
                    console.log('‚úÖ Basic functionality restored');
                } catch (fallbackError) {
                    console.error('‚ùå Fallback initialization also failed:', fallbackError);
                }
            }
        });

        // Check user role and redirect if necessary
        function checkUserRole() {
            if (!emergencySystem.user) {
                window.location.href = 'login.html';
                return false;
            }
            
            const userRole = emergencySystem.user?.user_metadata?.role || 'citizen';
            
            if (userRole !== 'responder' && userRole !== 'admin' && userRole !== 'super_user') {
                if (userRole === 'citizen') {
                    window.location.href = 'user.html';
                } else if (userRole === 'admin' || userRole === 'super_user') {
                    window.location.href = 'admin.html';
                }
                return false;
            }
            
            return true;
        }

        // Get responder ID from database
        async function getResponderId() {
            try {
                if (!emergencySystem.user) {
                    console.warn('‚ö†Ô∏è No user found, cannot get responder ID');
                    return;
                }
                
                console.log('üîç Looking for responder with user ID:', emergencySystem.user.id);
                
                const { data, error } = await emergencySystem.supabase
                    .from('responder')
                    .select('id, is_available, name, role')
                    .eq('user_id', emergencySystem.user.id)
                    .single();
                
                if (error) {
                    console.warn('‚ö†Ô∏è No responder found for user, creating one...');
                    
                    // Create a new responder entry
                    const { data: newResponder, error: createError } = await emergencySystem.supabase
                        .from('responder')
                        .insert({
                            user_id: emergencySystem.user.id,
                            name: emergencySystem.user.user_metadata?.full_name || emergencySystem.user.email.split('@')[0],
                            role: 'Emergency Responder',
                            is_available: true,
                            status: 'available'
                        })
                        .select('id, is_available, name, role')
                        .single();
                    
                    if (createError) {
                        console.error('‚ùå Failed to create responder:', createError);
                        return;
                    }
                    
                    responderId = newResponder.id;
                    isAvailable = newResponder.is_available;
                    console.log('‚úÖ Created new responder with ID:', responderId);
                } else {
                    responderId = data.id;
                    isAvailable = data.is_available;
                    console.log('‚úÖ Found existing responder ID:', responderId);
                }
                
                // Update user info in UI
                if (data && data.name) {
                    document.getElementById('userName').textContent = data.name;
                    document.getElementById('userAvatar').textContent = data.name.charAt(0).toUpperCase();
                }
                
            } catch (error) {
                console.error('‚ùå Error getting responder ID:', error);
                // Continue without responder ID - user can still view reports
                console.log('‚ÑπÔ∏è Continuing without responder ID - will show all reports');
            }
        }

        // Load dashboard data
        async function loadDashboardData() {
            try {
                // Load assigned reports
                await loadAssignedReports();
                
                // Update dashboard stats (this will also load completed assignments)
                await updateDashboardStats();
                
                // Update recent assignments
                updateRecentAssignments();
                
                // Update completed assignments
                updateCompletedAssignments();
                
                // Update responder statistics
                updateResponderStatistics();
                
            } catch (error) {
                console.error('Error loading dashboard data:', error);
            }
        }

        // Load assigned reports
        async function loadAssignedReports() {
            try {
                console.log('üìã Loading assignments for responder:', responderId);
                
                if (!responderId) {
                    console.warn('‚ö†Ô∏è No responder ID available, cannot load assignments');
                    currentReports = [];
                    displayAssignments();
                    return;
                }
                
                // Load assignments for this responder only, excluding resolved and cancelled
                console.log('üîç Querying assignments with filters:', {
                    responderId: responderId,
                    statusFilter: ['assigned', 'accepted', 'enroute', 'on_scene']
                });
                
                // Query assignments first
                const { data: assignments, error: assignmentError } = await emergencySystem.supabase
                    .from('assignment')
                    .select('*')
                    .eq('responder_id', responderId)
                    .in('status', ['assigned', 'accepted', 'enroute', 'on_scene'])
                    .order('assigned_at', { ascending: false });
                    
                if (assignmentError) {
                    console.error('‚ùå Failed to load assignments:', assignmentError);
                            currentReports = [];
                    return;
                }
                
                if (!assignments || assignments.length === 0) {
                    console.log('‚úÖ No active assignments found');
                    currentReports = [];
                    displayAssignments();
                    return;
                }
                
                // Get report IDs and fetch reports separately
                const reportIds = assignments.map(a => a.report_id).filter(Boolean);
                const responderIds = [...new Set(assignments.map(a => a.responder_id).filter(Boolean))];
                
                // Fetch reports
                const { data: reports, error: reportsError } = await emergencySystem.supabase
                    .from('reports')
                    .select('id, message, type, status, created_at, location, reporter_name, image_path')
                    .in('id', reportIds);
                
                // Fetch responders
                const { data: responders, error: respondersError } = await emergencySystem.supabase
                    .from('responder')
                    .select('id, name, role')
                    .in('id', responderIds);
                
                // Create lookup maps
                const reportsMap = new Map((reports || []).map(r => [r.id, r]));
                const respondersMap = new Map((responders || []).map(r => [r.id, r]));
                
                // Combine assignments with reports and responders
                    currentReports = assignments.map(assignment => {
                    const report = reportsMap.get(assignment.report_id);
                    const responder = respondersMap.get(assignment.responder_id);
                    
                    if (!report) {
                        console.warn('‚ö†Ô∏è Report not found for assignment:', assignment.id);
                        return null;
                    }
                        
                        return {
                            id: report.id,
                            message: report.message,
                            type: report.type,
                        status: assignment.status,
                        created_at: assignment.assigned_at,
                            location: report.location,
                            reporter_name: report.reporter_name,
                            image_path: report.image_path,
                            assignment_id: assignment.id,
                            assignment_status: assignment.status,
                            assigned_at: assignment.assigned_at,
                            accepted_at: assignment.accepted_at,
                            completed_at: assignment.completed_at,
                        responder_name: responder?.name,
                        responder_role: responder?.role,
                        is_assigned_to_me: true
                        };
                    }).filter(report => report !== null);
                    
                console.log('‚úÖ Loaded assignments for responder:', currentReports.length);
                displayAssignments();
                
                // Update map view with new reports
                updateMapView();
                
            } catch (error) {
                console.error('‚ùå Error loading reports:', error);
                currentReports = [];
                displayAssignments();
                
                // Show user-friendly error
                const alertsContainer = document.querySelector('.alerts-container');
                if (alertsContainer) {
                    alertsContainer.innerHTML = `
                        <div class="alert alert-warning">
                            <strong>Unable to load reports</strong><br>
                            Please check your connection and try refreshing the page.
                        </div>
                    `;
                }
            }
        }

        // Display assignments in the UI
        function displayAssignments() {
            const assignmentsList = document.getElementById('assignmentsList');
            if (!assignmentsList) return;
            
            // Filter out completed/resolved assignments - only show active assignments
            const activeAssignments = currentReports.filter(report => 
                report.assignment_status !== 'resolved' && 
                report.assignment_status !== 'completed' &&
                report.assignment_status !== 'cancelled'
            );
            
            if (activeAssignments.length === 0) {
                assignmentsList.innerHTML = '<div class="text-center p-4 text-gray-500">No active assignments found</div>';
                return;
            }
            
            assignmentsList.innerHTML = activeAssignments.map(report => `
                <div class="emergency-item ${report.is_assigned_to_me ? 'assigned-to-me' : ''}" onclick="selectAssignment('${report.id}')">
                    <div class="emergency-icon">
                        ${getEmergencyIcon(report.type)}
                        </div>
                    <div class="emergency-details">
                        <h4 class="emergency-title">${report.type || 'Emergency'}</h4>
                        <p class="emergency-location">${formatLocation(report.location)}</p>
                        <p class="emergency-time">Assigned: ${new Date(report.assigned_at).toLocaleString()}</p>
                        <p class="emergency-assignee">
                            <strong>Assigned to:</strong> ${report.responder_name || 'Unknown'} (${report.responder_role || 'Responder'})
                        </p>
                        ${report.reporter_name ? `<p class="emergency-reporter"><strong>Reporter:</strong> ${report.reporter_name}</p>` : ''}
                    </div>
                    <div class="emergency-status ${report.assignment_status}">
                        ${report.assignment_status === 'accepted' ? '' : `<span class="status-badge ${report.assignment_status}">${report.assignment_status.toUpperCase()}</span>`}
                        ${report.is_assigned_to_me ? '<span class="my-assignment-badge">MY ASSIGNMENT</span>' : ''}
                    </div>
                                </div>
            `).join('');
        }

        // Select an assignment for detailed view
        function selectAssignment(reportId) {
            const report = currentReports.find(r => r.id === reportId);
            if (!report) return;
            
            // Update active state
            document.querySelectorAll('.emergency-item').forEach(item => {
                item.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
            
            // Show assignment details
            showAssignmentDetails(report);
        }

        // Show assignment details
        function showAssignmentDetails(report) {
            const detailsContainer = document.getElementById('assignmentDetails');
            const detailsContent = document.getElementById('assignmentDetailsContent');
            
            if (!detailsContainer || !detailsContent) return;
            
            detailsContainer.style.display = 'block';
            
            detailsContent.innerHTML = `
                <div class="form-group">
                    <label class="form-label">Emergency Type</label>
                    <div class="form-control">${report.type || 'Unknown'}</div>
                            </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <div class="form-control">${report.message || 'No description'}</div>
                </div>
                ${report.image_path ? `
                <div class="form-group">
                    <label class="form-label">Emergency Photo</label>
                    <div class="form-control">
                        <img src="${report.image_path}" alt="Emergency Photo" style="max-width: 300px; max-height: 200px; width: auto; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; object-fit: cover;" onclick="openImageModal('${report.image_path}')">
                        <p style="margin-top: 8px; font-size: 12px; color: #6b7280; text-align: center;">Click image to view full size</p>
                    </div>
                </div>
                ` : ''}
                <div class="form-group">
                    <label class="form-label">Location</label>
                    <div class="form-control">${formatLocation(report.location)}</div>
                            </div>
                <div class="form-group">
                    <label class="form-label">Assignment Status</label>
                    <div class="form-control">
                        <span class="status-badge ${report.assignment_status}">${report.assignment_status.toUpperCase()}</span>
                    </div>
                            </div>
                <div class="form-group">
                    <label class="form-label">Assigned To</label>
                    <div class="form-control">${report.responder_name || 'Unknown'} (${report.responder_role || 'Responder'})</div>
                        </div>
                <div class="form-group">
                    <label class="form-label">Assignment Date</label>
                    <div class="form-control">${new Date(report.assigned_at).toLocaleString()}</div>
                </div>
                ${report.accepted_at ? `
                <div class="form-group">
                    <label class="form-label">Accepted At</label>
                    <div class="form-control">${new Date(report.accepted_at).toLocaleString()}</div>
                </div>
                ` : ''}
                ${report.completed_at ? `
                <div class="form-group">
                    <label class="form-label">Completed At</label>
                    <div class="form-control">${new Date(report.completed_at).toLocaleString()}</div>
                </div>
                ` : ''}
                ${report.reporter_name ? `
                <div class="form-group">
                    <label class="form-label">Reporter</label>
                    <div class="form-control">${report.reporter_name}</div>
                </div>
                ` : ''}
                <div class="form-actions">
                    <button class="btn btn-primary" onclick="navigateToReport('${report.id}')">
                        <i class="bi bi-navigation"></i> Navigate
                    </button>
                    ${!report.is_assigned_to_me ? `
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle"></i> This assignment is assigned to another responder.
                    </div>
                    ` : ''}
                    </div>
                `;
        }

        // Navigate to another responder's location
        async function navigateToResponder(responderIdParam, lat, lng, responderName) {
            try {
                console.log(`üß≠ Navigating to responder: ${responderName}`);
                
                // Switch to Map View section
                showSection('map');
                
                // Show loading message
                emergencySystem.showInfo('Getting your current location...');
                
                // Get current location and start navigation
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        async (position) => {
                            const from = [position.coords.latitude, position.coords.longitude];
                            const to = [parseFloat(lat), parseFloat(lng)];
                            
                            console.log('üìç Current location obtained:', from);
                            console.log('üéØ Navigating to responder:', to);
                            
                            // Create a dummy report object for navigation
                            const dummyReport = {
                                id: `responder-${responderIdParam}`,
                                type: 'responder',
                                message: `Navigating to ${responderName}`,
                                location: JSON.stringify({ latitude: to[0], longitude: to[1] })
                            };
                            
                            // Ensure other responders are visible
                            if (responderId) {
                                await loadOtherResponders();
                            }
                            
                            // Start navigation
                            await startRealWorldNavigation(from, to, dummyReport);
                        },
                        (error) => {
                            console.error('‚ùå Geolocation error:', error);
                            let errorMessage = 'Unable to get current location';
                            
                            if (error.code === 1) {
                                errorMessage = 'Location access denied. Please allow location access and try again.';
                            } else if (error.code === 2) {
                                errorMessage = 'Location unavailable. Please check your GPS settings.';
                            } else if (error.code === 3) {
                                errorMessage = 'Location request timed out. Please try again.';
                            }
                            
                            emergencySystem.showError(errorMessage);
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 300000
                        }
                    );
                } else {
                    emergencySystem.showError('Geolocation not supported by this browser');
                }
                
            } catch (error) {
                console.error('‚ùå Error navigating to responder:', error);
                emergencySystem.showError('Failed to navigate to responder: ' + error.message);
            }
        }

        // Navigate to report location
        function navigateToReport(reportId) {
            const report = currentReports.find(r => r.id === reportId);
            if (!report) {
                console.error('‚ùå Report not found:', reportId);
                emergencySystem.showError('Report not found');
                return;
            }
            
            try {
                console.log('üìç Navigating to report:', report.id);
                
                // Switch to Map View section
                showSection('map');
                
                // Wait for map to be ready, then show the assignment location
                setTimeout(() => {
                    showAssignmentOnMap(report);
                }, 500);
                
            } catch (error) {
                console.error('‚ùå Navigation error:', error);
                emergencySystem.showError('Failed to navigate to assignment');
            }
        }
        
        // Show assignment location on map
        function showAssignmentOnMap(report) {
            try {
                // Check if assignment is resolved - don't show resolved assignments on map
                if (report.assignment_status === 'resolved' || 
                    report.assignment_status === 'completed' || 
                    report.assignment_status === 'cancelled') {
                    console.log('‚ö†Ô∏è Assignment is resolved/completed, not showing on map:', report.id);
                    emergencySystem.showWarning('This assignment has already been resolved and is not shown on the map.');
                    return;
                }
                
                let targetLocation;
                
                console.log('üìç Processing location data for report:', report.id);
                console.log('üìç Location data:', report.location);
                
                if (report.location) {
                    if (typeof report.location === 'string') {
                        // Check if it looks like JSON (starts with { or [)
                        const trimmed = report.location.trim();
                        if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
                            try {
                                const locationData = JSON.parse(report.location);
                                // Try different coordinate field names
                                const lat = locationData.latitude || locationData.lat || locationData.y;
                                const lng = locationData.longitude || locationData.lng || locationData.lon || locationData.x;
                                
                                if (lat != null && lng != null) {
                                    targetLocation = [parseFloat(lat), parseFloat(lng)];
                                    console.log('‚úÖ Parsed location coordinates from JSON:', targetLocation);
                                } else {
                                    console.warn('‚ö†Ô∏è Location JSON missing coordinates:', locationData);
                                    // Try to extract from nested objects
                                    if (locationData.location) {
                                        const nested = locationData.location;
                                        const nestedLat = nested.latitude || nested.lat;
                                        const nestedLng = nested.longitude || nested.lng || nested.lon;
                                        if (nestedLat != null && nestedLng != null) {
                                            targetLocation = [parseFloat(nestedLat), parseFloat(nestedLng)];
                                            console.log('‚úÖ Parsed nested location coordinates:', targetLocation);
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn('‚ö†Ô∏è Failed to parse location JSON, trying coordinate extraction:', e);
                                // Try to extract coordinates from string like "lat,lng" or "latitude,longitude"
                                const coordMatch = report.location.match(/(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);
                                if (coordMatch) {
                                    targetLocation = [parseFloat(coordMatch[1]), parseFloat(coordMatch[2])];
                                    console.log('‚úÖ Extracted coordinates from string:', targetLocation);
                                } else {
                                    console.error('‚ùå Location is plain text address, no coordinates available:', report.location);
                                    emergencySystem.showError('Location is an address string. Coordinates are required for navigation.');
                                    return;
                                }
                            }
                        } else {
                            // It's a plain text string (address), try to extract coordinates
                            const coordMatch = report.location.match(/(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);
                            if (coordMatch) {
                                targetLocation = [parseFloat(coordMatch[1]), parseFloat(coordMatch[2])];
                                console.log('‚úÖ Extracted coordinates from address string:', targetLocation);
                            } else {
                                console.error('‚ùå Location is plain text address with no coordinates:', report.location);
                                emergencySystem.showError('Location is an address string. Coordinates are required for navigation. Please update the report with GPS coordinates.');
                                return;
                            }
                        }
                    } else if (typeof report.location === 'object') {
                        // Handle object format - try different field names
                        const lat = report.location.latitude || report.location.lat || report.location.y;
                        const lng = report.location.longitude || report.location.lng || report.location.lon || report.location.x;
                        
                        if (lat != null && lng != null) {
                            targetLocation = [parseFloat(lat), parseFloat(lng)];
                            console.log('‚úÖ Direct location coordinates from object:', targetLocation);
                        } else {
                            // Try nested location object
                            if (report.location.location) {
                                const nested = report.location.location;
                                const nestedLat = nested.latitude || nested.lat;
                                const nestedLng = nested.longitude || nested.lng || nested.lon;
                                if (nestedLat != null && nestedLng != null) {
                                    targetLocation = [parseFloat(nestedLat), parseFloat(nestedLng)];
                                    console.log('‚úÖ Nested location coordinates:', targetLocation);
                                }
                            }
                        }
                    }
                    
                    if (!targetLocation) {
                        console.warn('‚ö†Ô∏è No valid location coordinates found in:', report.location);
                        emergencySystem.showError('No valid GPS coordinates found. Please update the report with location coordinates.');
                        return;
                    }
                } else {
                    console.warn('‚ö†Ô∏è No location data in report');
                    emergencySystem.showError('No location data available');
                    return;
                }
                
                // Initialize map if not already done
                if (!responderMap) {
                    console.log('üó∫Ô∏è Initializing map for navigation...');
                    initializeMap();
                }
                
                // Wait for map to be ready, then add assignment marker
                setTimeout(() => {
                    if (responderMap) {
                        addAssignmentMarkerToMap(report, targetLocation);
                        emergencySystem.showSuccess('Assignment location displayed on map');
                    } else {
                        console.error('‚ùå Map not available');
                        emergencySystem.showError('Map not available');
                    }
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Error showing assignment on map:', error);
                emergencySystem.showError('Failed to show assignment location');
            }
        }
        
        // Add assignment marker to map
        function addAssignmentMarkerToMap(report, location) {
            if (!responderMap) return;
            
            try {
                console.log('üìç Adding assignment marker to map:', location);
                
                // Clear existing assignment markers
                responderMap.eachLayer(layer => {
                    if (layer.assignmentMarker) {
                        responderMap.removeLayer(layer);
                    }
                });
                
                // Add assignment marker
                const assignmentMarker = L.marker(location, {
                    icon: L.divIcon({
                        className: 'assignment-marker',
                        html: `<div style="background: ${getEmergencyColor(report.type)}; color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 20px; border: 3px solid white; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">${getEmergencyIcon(report.type)}</div>`,
                        iconSize: [40, 40],
                        iconAnchor: [20, 20]
                    })
                }).addTo(responderMap);
                
                // Mark as assignment marker for cleanup
                assignmentMarker.assignmentMarker = true;
                
                // Add popup with assignment details
                assignmentMarker.bindPopup(`
                    <div style="min-width: 300px;">
                        <div style="background: ${getEmergencyColor(report.type)}; color: white; padding: 10px; margin: -10px -10px 10px -10px; border-radius: 5px 5px 0 0;">
                            <h4 style="margin: 0; font-size: 18px;">${report.type.toUpperCase()} EMERGENCY</h4>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <p><strong>üìç Location:</strong> ${formatLocation(report.location)}</p>
                            <p><strong>‚è∞ Assigned:</strong> ${new Date(report.assigned_at).toLocaleString()}</p>
                            <p><strong>üë§ Assigned to:</strong> ${report.responder_name || 'Unknown'}</p>
                            ${report.reporter_name ? `<p><strong>üìû Reporter:</strong> ${report.reporter_name}</p>` : ''}
                        </div>
                        <div style="margin-top: 15px; display: flex; gap: 10px;">
                            <button onclick="startNavigationFromMap('${report.id}')" style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; transition: all 0.2s ease;">
                                <i class="bi bi-navigation"></i> Start Navigation
                            </button>
                        </div>
                        <div style="margin-top: 10px; padding: 8px; background: #f0f9ff; border-radius: 4px; font-size: 12px; color: #0369a1;">
                            <i class="bi bi-info-circle"></i> <strong>Navigation:</strong> Click "Start Navigation" to get turn-by-turn directions. The assignment will be automatically marked as complete when you reach the destination.
                        </div>
                    </div>
                `);
                
                // Center map on assignment location
                responderMap.setView(location, 16);
                
                // Open popup automatically
                assignmentMarker.openPopup();
                
                console.log('‚úÖ Assignment marker added to map');
                
            } catch (error) {
                console.error('‚ùå Error adding assignment marker:', error);
                emergencySystem.showError('Failed to add assignment marker to map');
            }
        }
        
        // Start navigation from map
        function startNavigationFromMap(reportId) {
            const report = currentReports.find(r => r.id === reportId);
            if (!report) {
                console.error('‚ùå Report not found:', reportId);
                emergencySystem.showError('Report not found');
                return;
            }
            
            console.log('üß≠ Starting navigation from map for report:', reportId);
            
            // Show loading message
            emergencySystem.showInfo('Getting your current location...');
            
            // Get current location and start navigation
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const currentLocation = [position.coords.latitude, position.coords.longitude];
                        console.log('üìç Current location obtained:', currentLocation);
                        
                        let targetLocation;
                        
                        if (report.location) {
                            if (typeof report.location === 'string') {
                                try {
                                    const locationData = JSON.parse(report.location);
                                    targetLocation = [parseFloat(locationData.latitude), parseFloat(locationData.longitude)];
                                } catch (e) {
                                    console.error('‚ùå Failed to parse location JSON:', e);
                                    emergencySystem.showError('Invalid location data format');
                                    return;
                                }
                            } else {
                                targetLocation = [parseFloat(report.location.latitude), parseFloat(report.location.longitude)];
                            }
                            
                            console.log('üéØ Target location:', targetLocation);
                            
                            // Start real-world navigation
                            startRealWorldNavigation(currentLocation, targetLocation, report);
                            
                        } else {
                            console.error('‚ùå No location data in report');
                            emergencySystem.showError('No location data available for this assignment');
                        }
                        },
                        (error) => {
                            console.error('‚ùå Geolocation error:', error);
                        let errorMessage = 'Unable to get current location';
                        
                        if (error.code === 1) {
                            errorMessage = 'Location access denied. Please allow location access and try again.';
                        } else if (error.code === 2) {
                            errorMessage = 'Location unavailable. Please check your GPS settings.';
                        } else if (error.code === 3) {
                            errorMessage = 'Location request timed out. Please try again.';
                        }
                        
                        emergencySystem.showError(errorMessage);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 300000
                        }
                    );
                } else {
                console.error('‚ùå Geolocation not supported');
                emergencySystem.showError('Geolocation not supported by this browser');
            }
        }

        // Start navigation
        async function startNavigation(from, to, report) {
            try {
                console.log('üß≠ Starting real-world navigation from', from, 'to', to);
                
                // Show loading message
                emergencySystem.showInfo('Calculating real-world route...');
                
                // Use real-world routing with OSRM
                await startRealWorldNavigation(from, to, report);
                
            } catch (error) {
                console.error('‚ùå Navigation start error:', error);
                emergencySystem.showError('Failed to start navigation: ' + error.message);
            }
        }
        
        // Start real-world navigation with OSRM routing
        async function startRealWorldNavigation(from, to, report) {
            try {
                console.log('üó∫Ô∏è Using real-world OSRM routing...');
                
                // Ensure other responders are visible on map
                if (responderId) {
                    await loadOtherResponders();
                }
                
                // Remove existing routing control
                if (routingControl) {
                    responderMap.removeControl(routingControl);
                }
                
                // Create new routing control with real road data
                routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(from[0], from[1]),
                        L.latLng(to[0], to[1])
                    ],
                    routeWhileDragging: true,
                    addWaypoints: false,
                    createMarker: function(i, waypoint, n) {
                        const marker = L.marker(waypoint.latLng, {
                            icon: L.divIcon({
                                className: 'routing-marker',
                                html: `<div style="background: ${i === 0 ? '#3b82f6' : '#ef4444'}; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${i === 0 ? 'üöó' : 'üéØ'}</div>`,
                                iconSize: [30, 30],
                                iconAnchor: [15, 15]
                            })
                        });
                        
                        if (i === 0) {
                            marker.bindPopup(`
                                <div style="min-width: 200px;">
                                    <h4 style="margin: 0 0 10px 0; color: #3b82f6;">üöó Your Location</h4>
                                    <p><strong>Status:</strong> Starting point</p>
                                    <p><strong>Accuracy:</strong> High precision</p>
                                </div>
                            `);
                        } else {
                            marker.bindPopup(`
                                <div style="min-width: 200px;">
                                    <h4 style="margin: 0 0 10px 0; color: #ef4444;">üéØ ${report.type === 'responder' ? 'Responder Location' : 'Emergency Location'}</h4>
                                    <p><strong>Status:</strong> Destination</p>
                                    <p><strong>Priority:</strong> High</p>
                                    ${report.type === 'responder' ? `<p><strong>Responder:</strong> ${report.message.replace('Navigating to ', '')}</p>` : ''}
                                </div>
                            `);
                        }
                        
                        return marker;
                    },
                    lineOptions: {
                        styles: [
                            {color: '#10b981', weight: 6, opacity: 0.9}
                        ]
                    },
                    show: false, // Hide default routing control
                    router: L.Routing.osrmv1({
                        serviceUrl: 'https://routing.openstreetmap.de/routed-foot/route/v1',
                        profile: 'foot'
                    })
                }).addTo(responderMap);
                
                // Listen for route calculation
                routingControl.on('routesfound', async function(e) {
                    const routes = e.routes;
                    let route = routes[0];
                    
                    // Check if route should go directly through Open Field
                    const waypoints = routingControl.getWaypoints();
                    if (waypoints && waypoints.length >= 2) {
                        const from = waypoints[0].latLng;
                        const to = waypoints[waypoints.length - 1].latLng;
                        
                        if (shouldUseDirectFieldRoute(from, to)) {
                            console.log('üö∂ Routing directly through Open Field (walkable area)');
                            const directRoutePoints = createDirectFieldRoute(from, to);
                            const totalDistance = from.distanceTo(to);
                            
                            // Create a modified route object with direct field route
                            route = {
                                ...route,
                                coordinates: directRoutePoints.map(p => [p.lng, p.lat]),
                                inputCoordinates: directRoutePoints.map(p => [p.lng, p.lat]),
                                summary: {
                                    totalDistance: totalDistance,
                                    totalTime: (totalDistance / 1000 / 5) * 3600, // 5 km/h walking speed
                                    waypointIndices: [0, directRoutePoints.length - 1]
                                },
                                instructions: [
                                    {
                                        text: 'Walk directly through the open field',
                                        distance: totalDistance,
                                        time: (totalDistance / 1000 / 5) * 3600,
                                        index: 0
                                    }
                                ]
                            };
                        }
                    }
                    
                    console.log('‚úÖ Real-world route calculated successfully');
                    console.log('üìè Route distance:', route.summary.totalDistance, 'meters');
                    console.log('‚è±Ô∏è Route duration:', route.summary.totalTime, 'seconds');
                    
                    // Create navigation data with real-world instructions
                    window.navigationData = {
                        instructions: route.instructions ? route.instructions.map(instruction => ({
                            instruction: instruction.text,
                            distance: instruction.distance,
                            duration: instruction.time,
                            direction: instruction.direction
                        })) : [],
                        currentStep: 0,
                        report: report,
                        route: route,
                        startTime: new Date(),
                        estimatedArrival: new Date(Date.now() + route.summary.totalTime * 1000),
                        totalDistance: Math.round(route.summary.totalDistance / 1000 * 10) / 10 + ' km',
                        totalDuration: Math.round(route.summary.totalTime / 60) + ' mins',
                        isNavigatingToResponder: report.type === 'responder'
                    };
                    
                    // Show navigation panel with real-world data
                    showRealWorldNavigationPanel();
                    
                    // Ensure other responders remain visible during navigation
                    if (responderId) {
                        await loadOtherResponders();
                    }
                    
                    const destinationType = report.type === 'responder' ? 'responder' : 'emergency location';
                    emergencySystem.showSuccess(`Real-world navigation route started to ${destinationType}`);
                });
                
                // Listen for routing errors
                routingControl.on('routingerror', function(e) {
                    console.warn('‚ö†Ô∏è Routing error:', e);
                    emergencySystem.showWarning('Routing service temporarily unavailable. Using fallback route.');
                    startFallbackNavigation(from, to, report);
                });
                
            } catch (error) {
                console.error('‚ùå Real-world navigation error:', error);
                startFallbackNavigation(from, to, report);
            }
        }
        
        // Start Google Maps navigation with real-world routing
        async function startGoogleMapsNavigation(from, to, report) {
            try {
                console.log('üó∫Ô∏è Using Google Maps for real-world routing...');
                
                const request = {
                    origin: new google.maps.LatLng(from[0], from[1]),
                    destination: new google.maps.LatLng(to[0], to[1]),
                    travelMode: google.maps.TravelMode.WALKING,
                    avoidHighways: false,
                    avoidTolls: false,
                    provideRouteAlternatives: true
                };
                
                directionsService.route(request, (result, status) => {
                    if (status === google.maps.DirectionsStatus.OK) {
                        console.log('‚úÖ Google Maps route calculated successfully');
                        
                        // Set the route on the map
                        directionsRenderer.setDirections(result);
                        directionsRenderer.setMap(googleMap);
                        
                        // Extract route information
                        const route = result.routes[0];
                        const leg = route.legs[0];
                        
                        // Create navigation data with real-world instructions
                        window.navigationData = {
                            instructions: leg.steps.map(step => ({
                                instruction: step.instructions,
                                distance: step.distance.text,
                                duration: step.duration.text,
                                startLocation: step.start_location,
                                endLocation: step.end_location
                            })),
                            currentStep: 0,
                            report: report,
                            route: route,
                            startTime: new Date(),
                            estimatedArrival: new Date(Date.now() + leg.duration.value * 1000),
                            totalDistance: leg.distance.text,
                            totalDuration: leg.duration.text
                        };
                        
                        // Show navigation panel with real-world data
                        showGoogleMapsNavigationPanel();
                        
                        emergencySystem.showSuccess('Real-world navigation route started');
                        
                    } else {
                        console.warn('‚ö†Ô∏è Google Maps routing failed:', status);
                        startFallbackNavigation(from, to, report);
                    }
                });
                
            } catch (error) {
                console.error('‚ùå Google Maps navigation error:', error);
                startFallbackNavigation(from, to, report);
            }
        }
        
        // Start fallback navigation
        async function startFallbackNavigation(from, to, report) {
            try {
                console.log('üõ£Ô∏è Using fallback routing...');
                
                // Create route with safe path calculation
                const route = await createSafeRoute(from, to, report);
                
                // Create navigation data with enhanced instructions
                window.navigationData = {
                    instructions: createNavigationSteps(route),
                    currentStep: 0,
                    report: report,
                    route: route,
                    startTime: new Date(),
                    estimatedArrival: new Date(Date.now() + (20 * 60 * 1000)) // 20 minutes from now
                };
                
                // Show navigation panel
                showNavigationPanel();
                
                // Draw route on map with safety indicators
                if (responderMap) {
                    if (responderNavigationRoute) {
                        responderMap.removeLayer(responderNavigationRoute);
                    }
                    
                    // Create route polyline with road-based styling
                    responderNavigationRoute = L.polyline(route, {
                        color: '#10b981', // Green for safe route
                        weight: 6,
                        opacity: 0.9,
                        dashArray: '15, 10', // Dashed line for road route
                        smoothFactor: 1.0 // Smooth the route line
                    }).addTo(responderMap);
                    
                    // Add safety markers along the route (spaced out more for road routes)
                    addRoadSafetyMarkers(route);
                    
                    // Fit map to route with padding
                    const bounds = L.latLngBounds(route);
                    responderMap.fitBounds(bounds, { padding: [50, 50] });
                }
                
                emergencySystem.showSuccess('Fallback navigation route started');
                
            } catch (error) {
                console.error('‚ùå Fallback navigation error:', error);
                emergencySystem.showError('Failed to start navigation: ' + error.message);
            }
        }
        
        // Create safe route with hazard avoidance
        async function createSafeRoute(from, to, report) {
            console.log('üõ£Ô∏è Creating safe route...');
            
            // Check if routing through Open Field - use direct path
            if (shouldUseDirectFieldRoute(from, to)) {
                console.log('üö∂ Creating direct route through Open Field (walkable area)');
                return createDirectFieldRoute(from, to);
            }
            
            try {
                // Use OpenRouteService API for real road-based routing
                const route = await getRoadBasedRoute(from, to);
                console.log('‚úÖ Road-based route created with', route.length, 'waypoints');
                return route;
            } catch (error) {
                console.warn('‚ö†Ô∏è Routing service failed, using fallback route:', error);
                // Fallback to a more realistic route that follows roads approximately
                return createRealisticFallbackRoute(from, to);
            }
        }
        
        // Get road-based route using local routing algorithm
        async function getRoadBasedRoute(from, to) {
            try {
                console.log('üõ£Ô∏è Creating local road-based route...');
                
                // Use a more sophisticated local routing algorithm
                const route = await createLocalRoadRoute(from, to);
                console.log('‚úÖ Local road route created with', route.length, 'points');
                return route;
            } catch (error) {
                console.warn('‚ö†Ô∏è Local routing failed:', error.message);
                throw error;
            }
        }
        
        // Create local road-based route using road network simulation
        async function createLocalRoadRoute(from, to) {
            console.log('üó∫Ô∏è Creating local road network route...');
            
            const latDiff = to[0] - from[0];
            const lngDiff = to[1] - from[1];
            const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
            
            // Create more realistic road-like path
            const numPoints = Math.max(15, Math.floor(distance * 200)); // More points for realism
            const route = [];
            
            // Add starting point
            route.push(from);
            
            // Create road-like waypoints
            for (let i = 1; i < numPoints - 1; i++) {
                const t = i / (numPoints - 1);
                
                // Create road-like curves and turns
                const roadCurve = createRoadCurve(t, latDiff, lngDiff);
                const lat = from[0] + latDiff * t + roadCurve.latOffset;
                const lng = from[1] + lngDiff * t + roadCurve.lngOffset;
                
                route.push([lat, lng]);
            }
            
            // Add ending point
            route.push(to);
            
            console.log('‚úÖ Local road route created with', route.length, 'waypoints');
            return route;
        }
        
        // Create road-like curves and turns
        function createRoadCurve(t, latDiff, lngDiff) {
            // Simulate road network with curves, turns, and intersections
            const roadPattern = Math.sin(t * Math.PI * 3) * 0.005; // Multiple curves
            const turnPattern = Math.cos(t * Math.PI * 2) * 0.003; // Turns
            const intersectionPattern = Math.sin(t * Math.PI * 5) * 0.002; // Intersections
            
            return {
                latOffset: roadPattern * Math.cos(t * Math.PI) + turnPattern * Math.sin(t * Math.PI * 2),
                lngOffset: roadPattern * Math.sin(t * Math.PI) + intersectionPattern * Math.cos(t * Math.PI * 3)
            };
        }
        
        // Create realistic fallback route that approximates road paths
        function createRealisticFallbackRoute(from, to) {
            console.log('üõ£Ô∏è Creating realistic fallback route...');
            
            const latDiff = to[0] - from[0];
            const lngDiff = to[1] - from[1];
            const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
            
            // Create more waypoints for a more realistic path
            const numPoints = Math.max(8, Math.floor(distance * 100)); // More points for longer distances
            const route = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                
                // Add some curvature to simulate road paths
                const curveFactor = Math.sin(t * Math.PI) * 0.01; // Slight curve
                const lat = from[0] + latDiff * t + curveFactor * Math.cos(t * Math.PI * 2);
                const lng = from[1] + lngDiff * t + curveFactor * Math.sin(t * Math.PI * 2);
                
                route.push([lat, lng]);
            }
            
            console.log('‚úÖ Realistic fallback route created with', route.length, 'waypoints');
            return route;
        }
        
        // Add safety markers along the route
        function addSafetyMarkers(route) {
            route.forEach((point, index) => {
                if (index > 0 && index < route.length - 1) {
                    const marker = L.marker(point, {
                        icon: L.divIcon({
                            className: 'safety-marker',
                            html: '<div style="background: #10b981; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white;">‚úì</div>',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    }).addTo(responderMap);
                    
                    marker.bindPopup(`
                        <div style="min-width: 200px;">
                            <h4 style="color: #10b981; margin: 0 0 10px 0;">‚úÖ Safe Waypoint</h4>
                            <p><strong>Route Point:</strong> ${index + 1} of ${route.length}</p>
                            <p><strong>Status:</strong> Safe to proceed</p>
                            <p><strong>Next:</strong> Continue on route</p>
                        </div>
                    `);
                }
            });
        }
        
        // Add road-based safety markers (spaced out for road routes)
        function addRoadSafetyMarkers(route) {
            // Only add markers at key points along the road route
            const stepSize = Math.max(1, Math.floor(route.length / 8)); // Max 8 markers
            
            for (let i = stepSize; i < route.length - stepSize; i += stepSize) {
                const point = route[i];
                const marker = L.marker(point, {
                    icon: L.divIcon({
                        className: 'road-safety-marker',
                        html: '<div style="background: #3b82f6; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 14px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üõ£Ô∏è</div>',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    })
                }).addTo(responderMap);
                
                marker.bindPopup(`
                    <div style="min-width: 220px;">
                        <h4 style="color: #3b82f6; margin: 0 0 10px 0;">üõ£Ô∏è Road Waypoint</h4>
                        <p><strong>Route Point:</strong> ${Math.floor(i / stepSize) + 1} of ${Math.floor(route.length / stepSize)}</p>
                        <p><strong>Road Status:</strong> Clear and safe</p>
                        <p><strong>Next:</strong> Continue on road</p>
                        <p><strong>Distance:</strong> ~${Math.round(calculateDistance(route[0], point) * 1000)}m from start</p>
                    </div>
                `);
            }
        }
        
        // Calculate distance between two points
        function calculateDistance(point1, point2) {
            const R = 6371; // Earth's radius in kilometers
            const dLat = (point2[0] - point1[0]) * Math.PI / 180;
            const dLon = (point2[1] - point1[1]) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(point1[0] * Math.PI / 180) * Math.cos(point2[0] * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Open image in modal for full size view
        function openImageModal(imagePath) {
            const modal = document.createElement('div');
            modal.className = 'image-modal-overlay';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                cursor: pointer;
            `;
            
            modal.innerHTML = `
                <div style="position: relative; max-width: 90%; max-height: 90%; background: white; border-radius: 8px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
                    <button onclick="this.closest('.image-modal-overlay').remove()" style="position: absolute; top: 10px; right: 15px; background: #ef4444; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;">√ó</button>
                    <img src="${imagePath}" alt="Emergency Photo" style="max-width: 100%; max-height: 80vh; border-radius: 4px;">
                    <div style="margin-top: 10px; text-align: center; color: #6b7280; font-size: 14px;">
                        Emergency Photo - Click outside to close
                    </div>
                </div>
            `;
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
            
            // Close modal with Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            document.body.appendChild(modal);
        }

        // View report details
        function viewReportDetails(reportId) {
            const report = currentReports.find(r => r.id === reportId);
            if (!report) {
                emergencySystem.showError('Report not found');
                return;
            }
            
            // Create detailed report modal
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 10px; padding: 20px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; color: #ef4444;">${report.type.toUpperCase()} EMERGENCY</h3>
                        <button onclick="this.closest('.modal-overlay').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                    </div>
                    
                    <div class="report-details">
                        <div style="margin-bottom: 15px;">
                            <strong>üìä Status:</strong> <span class="badge badge-${report.status}" style="background: #3b82f6; color: white; padding: 4px 8px; border-radius: 4px;">${report.status.toUpperCase()}</span>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <strong>üìç Location:</strong> ${formatLocation(report.location)}
                        </div>
                        <div style="margin-bottom: 15px;">
                            <strong>‚è∞ Time:</strong> ${new Date(report.created_at).toLocaleString()}
                        </div>
                        <div style="margin-bottom: 15px;">
                            <strong>üìù Description:</strong> ${report.message || 'No description provided'}
                        </div>
                        ${report.reporter_name ? `<div style="margin-bottom: 15px;"><strong>üë§ Reporter:</strong> ${report.reporter_name}</div>` : ''}
                        
                        <div style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;">
                            <h4 style="margin: 0 0 10px 0; color: #10b981;">üõ£Ô∏è Safe Route Information</h4>
                            <p><strong>Route Status:</strong> Safe route available</p>
                            <p><strong>Estimated Time:</strong> 15-20 minutes</p>
                            <p><strong>Distance:</strong> ~5.2 km</p>
                            <p><strong>Hazards:</strong> None detected</p>
                            <p><strong>Alternative Routes:</strong> 2 available</p>
                        </div>
                        
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="navigateToReport('${report.id}'); this.closest('.modal-overlay').remove();" style="background: #3b82f6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                                <i class="bi bi-navigation"></i> Start Navigation
                            </button>
                            <button onclick="this.closest('.modal-overlay').remove()" style="background: #6b7280; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // Update assignment status
        async function updateAssignmentStatus(assignmentId, status) {
            try {
                const updateData = {
                    status: status,
                    updated_at: new Date().toISOString()
                };
                
                // Add timestamp based on status
                if (status === 'accepted') {
                    updateData.accepted_at = new Date().toISOString();
                } else if (status === 'resolved') {
                    updateData.completed_at = new Date().toISOString();
                }
                
                // Update assignment status
                const { error: assignmentError } = await emergencySystem.supabase
                    .from('assignment')
                    .update(updateData)
                    .eq('id', assignmentId);
                
                if (assignmentError) {
                    console.error('‚ùå Failed to update assignment status:', assignmentError);
                    emergencySystem.showError('Failed to update assignment status');
                    return;
                }
                
                // If assignment is being marked as resolved/completed, also update the report status
                if (status === 'resolved' || status === 'completed') {
                    console.log('üîÑ Updating report status to completed for assignment:', assignmentId);
                    
                    // Get the assignment to find the report ID
                    const { data: assignment, error: fetchError } = await emergencySystem.supabase
                        .from('assignment')
                        .select('report_id')
                        .eq('id', assignmentId)
                        .single();
                    
                    console.log('üìã Assignment data:', assignment);
                    console.log('üìã Fetch error:', fetchError);
                    
                    if (!fetchError && assignment && assignment.report_id) {
                        console.log('üîÑ Updating report ID:', assignment.report_id, 'to completed status');
                        
                        // Update the report status to completed with retry logic
                        let retryCount = 0;
                        const maxRetries = 3;
                        let reportUpdateSuccess = false;
                        
                        while (retryCount < maxRetries && !reportUpdateSuccess) {
                            try {
                                const { data: updateData, error: reportError } = await emergencySystem.supabase
                                    .from('reports')
                                    .update({ 
                                        status: 'completed'
                                    })
                                    .eq('id', assignment.report_id)
                                    .select();
                                
                                console.log(`üìä Report update attempt ${retryCount + 1} result:`, updateData);
                                console.log(`üìä Report update attempt ${retryCount + 1} error:`, reportError);
                                
                                if (reportError) {
                                    console.warn(`‚ö†Ô∏è Report update attempt ${retryCount + 1} failed:`, reportError);
                                    retryCount++;
                                    if (retryCount < maxRetries) {
                                        console.log(`üîÑ Retrying report update in 1 second...`);
                                        await new Promise(resolve => setTimeout(resolve, 1000));
                                    }
                                } else {
                                    reportUpdateSuccess = true;
                                    console.log('‚úÖ Report status updated to completed successfully');
                                    emergencySystem.showSuccess('Report status updated to completed');
                                }
                            } catch (retryError) {
                                console.error(`‚ùå Report update attempt ${retryCount + 1} exception:`, retryError);
                                retryCount++;
                                if (retryCount < maxRetries) {
                                    await new Promise(resolve => setTimeout(resolve, 1000));
                                }
                            }
                        }
                        
                        if (!reportUpdateSuccess) {
                            console.error('‚ùå Failed to update report status after all retries');
                            emergencySystem.showError('Failed to update report status after multiple attempts');
                        }
                    } else {
                        console.error('‚ùå Could not find assignment or report_id:', { assignment, fetchError });
                        emergencySystem.showError('Could not find associated report to update');
                    }
                }
                
                // Update local data
                const report = currentReports.find(r => r.assignment_id === assignmentId);
                if (report) {
                    report.assignment_status = status;
                    if (status === 'accepted') {
                        report.accepted_at = updateData.accepted_at;
                    } else if (status === 'resolved') {
                        report.completed_at = updateData.completed_at;
                        // Also update the report status in local data
                        report.status = 'completed';
                    }
                }
                
                // Refresh display
                displayAssignments();
                showAssignmentDetails(report);
                updateDashboardStats();
                updateRecentAssignments();
                updateCompletedAssignments();
                updateResponderStatistics();
                
                emergencySystem.showSuccess(`Assignment status updated to ${status}`);
                
            } catch (error) {
                console.error('‚ùå Error updating assignment status:', error);
                emergencySystem.showError('Failed to update assignment status');
            }
        }

        // Update report status (legacy function for compatibility)
        async function updateReportStatus(reportId, status) {
            try {
                const { error } = await emergencySystem.supabase
                    .from('reports')
                    .update({ status: status })
                    .eq('id', reportId);
                
                if (error) {
                    console.error('‚ùå Failed to update report status:', error);
                    emergencySystem.showError('Failed to update report status');
                    return;
                }
                
                // Update local data
                const report = currentReports.find(r => r.id === reportId);
                if (report) {
                    report.status = status;
                }
                
                // Refresh display
                displayAssignments();
                showAssignmentDetails(report);
                updateDashboardStats();
                
                emergencySystem.showSuccess(`Report status updated to ${status}`);
                
            } catch (error) {
                console.error('‚ùå Error updating report status:', error);
                emergencySystem.showError('Failed to update report status');
            }
        }

        // Initialize map
        function initializeMap() {
            try {
                console.log('üó∫Ô∏è Initializing real-world map...');
                
                const mapElement = document.getElementById('map');
                if (!mapElement) {
                    console.warn('‚ö†Ô∏è Map element not found');
                    return;
                }
                
                // Check if map is already initialized
                if (responderMap) {
                    console.log('üó∫Ô∏è Map already initialized, refreshing...');
                    responderMap.invalidateSize();
                    return;
                }
                
                // Check if Leaflet is loaded
                if (typeof L === 'undefined') {
                    console.error('‚ùå Leaflet library not loaded');
                    showMapError('Map library not loaded. Please refresh the page.');
                    return;
                }
                
                // Ensure map container has proper dimensions
                mapElement.style.width = '100%';
                mapElement.style.height = '100%';
                mapElement.style.minHeight = '500px';
                
                // Clear any existing content
                mapElement.innerHTML = '';
                
                // Wait for DOM to be ready
                setTimeout(() => {
                    try {
                        // Initialize map with LSPU coordinates
                        responderMap = L.map('map', {
                            center: [14.0741, 121.3298], // LSPU coordinates
                            zoom: 15,
                            zoomControl: true,
                            attributionControl: true
                        });
                        
                        console.log('‚úÖ Real-world map created successfully');
                        
                        // Add OpenStreetMap tiles with better styling
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '¬© OpenStreetMap contributors',
                            maxZoom: 19,
                            subdomains: ['a', 'b', 'c']
                        }).addTo(responderMap);
                        
                        // Initialize real-world routing
                        initializeRealRouting();
                        
                        // Add LSPU marker
                        const lspuMarker = L.marker([14.0741, 121.3298], {
                            icon: L.divIcon({
                                className: 'lspu-marker',
                                html: '<div style="background: #3b82f6; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">üè´</div>',
                                iconSize: [30, 30],
                                iconAnchor: [15, 15]
                            })
                        }).addTo(responderMap);
                        
                        lspuMarker.bindPopup(`
                            <div style="min-width: 200px;">
                                <h4 style="margin: 0 0 10px 0; color: #3b82f6;">üè´ LSPU Main Campus</h4>
                                <p><strong>Location:</strong> Santa Cruz, Laguna</p>
                                <p><strong>Status:</strong> Emergency Response Center</p>
                                <p><strong>Address:</strong> Brgy. Pagsawitan, Santa Cruz, Laguna</p>
                            </div>
                        `);
                        
                        console.log('‚úÖ Real-world map with routing initialized');
                        
                        // Force map to refresh
                        setTimeout(() => {
                            if (responderMap) {
                                responderMap.invalidateSize();
                                console.log('‚úÖ Map size invalidated');
                            }
                        }, 500);
                        
                        // Try to get user location after map is ready
                        setTimeout(() => {
                            initializeLocationTracking();
                        }, 1000);
                        
                    } catch (mapError) {
                        console.error('‚ùå Error creating real-world map:', mapError);
                        showMapError('Failed to create map: ' + mapError.message);
                    }
                }, 100);
                
            } catch (error) {
                console.error('‚ùå Failed to initialize map:', error);
                showMapError('Unable to load map. Please check your internet connection.');
            }
        }
        
        // Initialize Google Maps
        function initializeGoogleMap() {
            try {
                console.log('üó∫Ô∏è Initializing Google Maps...');
                
                const mapElement = document.getElementById('map');
                mapElement.style.width = '100%';
                mapElement.style.height = '100%';
                mapElement.style.minHeight = '400px';
                mapElement.innerHTML = '';
                
                // Initialize Google Map
                googleMap = new google.maps.Map(mapElement, {
                    center: { lat: 14.0741, lng: 121.3298 }, // LSPU coordinates
                    zoom: 15,
                    mapTypeId: google.maps.MapTypeId.ROADMAP,
                    mapTypeControl: true,
                    streetViewControl: true,
                    fullscreenControl: true,
                    zoomControl: true,
                    styles: [
                        {
                            featureType: 'poi',
                            elementType: 'labels',
                            stylers: [{ visibility: 'on' }]
                        }
                    ]
                });
                
                // Add LSPU marker
                const lspuMarker = new google.maps.Marker({
                    position: { lat: 14.0741, lng: 121.3298 },
                    map: googleMap,
                    title: 'LSPU Main Campus',
                    icon: {
                        url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                            <svg width="30" height="30" viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="15" cy="15" r="12" fill="#3b82f6" stroke="white" stroke-width="3"/>
                                <text x="15" y="20" text-anchor="middle" fill="white" font-size="16">üè´</text>
                            </svg>
                        `),
                        scaledSize: new google.maps.Size(30, 30)
                    }
                });
                
                const lspuInfoWindow = new google.maps.InfoWindow({
                    content: `
                        <div style="min-width: 200px;">
                            <h4 style="margin: 0 0 10px 0; color: #3b82f6;">üè´ LSPU Main Campus</h4>
                            <p><strong>Location:</strong> Santa Cruz, Laguna</p>
                            <p><strong>Status:</strong> Emergency Response Center</p>
                        </div>
                    `
                });
                
                lspuMarker.addListener('click', () => {
                    lspuInfoWindow.open(googleMap, lspuMarker);
                });
                
                console.log('‚úÖ Google Maps initialized successfully');
                
                // Try to get user location after map is ready
                setTimeout(() => {
                    initializeLocationTracking();
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Error initializing Google Maps:', error);
                initializeLeafletMap();
            }
        }
        
        // Initialize Leaflet map as fallback
        function initializeLeafletMap() {
            try {
                console.log('üó∫Ô∏è Initializing Leaflet fallback map...');
                
                const mapElement = document.getElementById('map');
                if (!mapElement) {
                    console.warn('‚ö†Ô∏è Map element not found');
                    return;
                }
                
                // Check if Leaflet is loaded
                if (typeof L === 'undefined') {
                    console.error('‚ùå Leaflet library not loaded');
                    showMapError('Map library not loaded. Please refresh the page.');
                    return;
                }
                
                // Ensure map container has proper dimensions
                mapElement.style.width = '100%';
                mapElement.style.height = '100%';
                mapElement.style.minHeight = '400px';
                
                // Clear any existing content
                mapElement.innerHTML = '';
                
                // Wait for DOM to be ready
                setTimeout(() => {
                    try {
                        // Initialize map with LSPU coordinates
                        responderMap = L.map('map', {
                            center: [14.0741, 121.3298], // LSPU coordinates
                            zoom: 15,
                            zoomControl: true,
                            attributionControl: true,
                            preferCanvas: false
                        });
                        
                        console.log('‚úÖ Leaflet map created successfully');
                        
                        // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '¬© OpenStreetMap contributors',
                            maxZoom: 19,
                            subdomains: ['a', 'b', 'c']
                }).addTo(responderMap);
                
                        // Add a default marker for LSPU
                        const defaultMarker = L.marker([14.0741, 121.3298], {
                            icon: L.divIcon({
                                className: 'default-marker',
                                html: '<div style="background: #3b82f6; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">üè´</div>',
                                iconSize: [30, 30],
                                iconAnchor: [15, 15]
                            })
                        }).addTo(responderMap);
                        
                        defaultMarker.bindPopup(`
                            <div style="min-width: 200px;">
                                <h4 style="margin: 0 0 10px 0; color: #3b82f6;">üè´ LSPU Main Campus</h4>
                                <p><strong>Location:</strong> Santa Cruz, Laguna</p>
                                <p><strong>Status:</strong> Emergency Response Center</p>
                            </div>
                        `);
                        
                        console.log('‚úÖ Leaflet map tiles and markers added successfully');
                        
                        // Force map to refresh
                        setTimeout(() => {
                            if (responderMap) {
                                responderMap.invalidateSize();
                                console.log('‚úÖ Map size invalidated');
                            }
                        }, 500);
                        
                        // Try to get user location after map is ready
                        setTimeout(() => {
                            initializeLocationTracking();
                        }, 1000);
                        
                    } catch (mapError) {
                        console.error('‚ùå Error creating Leaflet map:', mapError);
                        showMapError('Failed to create map: ' + mapError.message);
                    }
                }, 100);
                
            } catch (error) {
                console.error('‚ùå Failed to initialize Leaflet map:', error);
                showMapError('Unable to load map. Please check your internet connection.');
            }
        }
                
        // Show map error message
        function showMapError(message) {
                const mapElement = document.getElementById('map');
                if (mapElement) {
                    mapElement.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f8fafc; color: #6b7280; text-align: center; flex-direction: column; padding: 2rem;">
                        <i class="bi bi-map" style="font-size: 3rem; margin-bottom: 1rem; color: #dc2626;"></i>
                        <h3 style="color: #dc2626; margin-bottom: 0.5rem;">Map Unavailable</h3>
                        <p style="margin-bottom: 1rem;">${message}</p>
                        <button onclick="retryMapInitialization()" style="background: #3b82f6; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer;">
                            Retry
                        </button>
                        </div>
                    `;
            }
        }
        
        // Retry map initialization
        function retryMapInitialization() {
            console.log('üîÑ Retrying map initialization...');
            // Reset the map variable
            responderMap = null;
            // Clear the map container
            const mapElement = document.getElementById('map');
            if (mapElement) {
                mapElement.innerHTML = '';
            }
            // Try to initialize again
            setTimeout(() => {
                initializeMap();
            }, 100);
        }

        // Initialize location tracking
        function initializeLocationTracking() {
            if (navigator.geolocation) {
                console.log('üìç Starting real-time location tracking...');
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        currentLocation = [position.coords.latitude, position.coords.longitude];
                        console.log('üìç Current location:', currentLocation);
                        updateLocationOnMap();
                        
                        // Start continuous location tracking
                        startContinuousLocationTracking();
                    },
                    (error) => {
                        console.warn('‚ö†Ô∏è Geolocation error:', error);
                        if (error.code === 3) {
                            console.log('üìç Location timeout - continuing without location');
                        }
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 300000
                    }
                );
            } else {
                console.warn('‚ö†Ô∏è Geolocation not supported');
            }
        }
        
        // Start continuous location tracking for real-time updates
        function startContinuousLocationTracking() {
            if (!navigator.geolocation) return;
            
            console.log('üîÑ Starting continuous location tracking...');
            
            // Watch position for real-time updates
            const watchId = navigator.geolocation.watchPosition(
                (position) => {
                    const newLocation = [position.coords.latitude, position.coords.longitude];
                    
                    // Only update if location changed significantly
                    if (!currentLocation || 
                        Math.abs(currentLocation[0] - newLocation[0]) > 0.0001 ||
                        Math.abs(currentLocation[1] - newLocation[1]) > 0.0001) {
                        
                        currentLocation = newLocation;
                        console.log('üìç Location updated:', currentLocation);
                        updateLocationOnMap();
                        
                        // Update navigation if active
                        if (window.navigationData && responderNavigationRoute) {
                            updateNavigationWithCurrentLocation();
                        }
                        
                        // Refresh other responders periodically (every 10 location updates)
                        if (window.locationUpdateCount === undefined) {
                            window.locationUpdateCount = 0;
                        }
                        window.locationUpdateCount++;
                        if (window.locationUpdateCount % 10 === 0 && responderId) {
                            loadOtherResponders();
                        }
                    }
                },
                (error) => {
                    if (error.code === 3) { // TIMEOUT
                        console.warn('‚ö†Ô∏è Location timeout - continuing without real-time tracking');
                    } else {
                        console.warn('‚ö†Ô∏è Location watch error:', error);
                    }
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 30000 // 30 seconds cache
                }
            );
            
            // Store watch ID for cleanup
            window.locationWatchId = watchId;
            console.log('‚úÖ Continuous location tracking started');
        }
        
        // Update navigation with current responder location
        function updateNavigationWithCurrentLocation() {
            if (!currentLocation || !window.navigationData) return;
            
            console.log('üß≠ Updating navigation with current location...');
            
            const currentPos = currentLocation;
            const targetPos = window.navigationData.route[window.navigationData.route.length - 1];
            
            // Check if we're close to the target
            const distance = calculateDistance(currentPos, targetPos);
            if (distance < 0.1) { // Within 100m
                console.log('üéØ Arrived at destination!');
                emergencySystem.showSuccess('You have arrived at the emergency location!');
                return;
            }
            
            // Update route from current position
            updateRouteFromCurrentPosition(currentPos, targetPos);
        }
        
        // Update route from current position to target
        function updateRouteFromCurrentPosition(currentPos, targetPos) {
            try {
                // Remove old route
                if (responderNavigationRoute) {
                    responderMap.removeLayer(responderNavigationRoute);
                }
                
                // Create new route from current position
                createSafeRoute(currentPos, targetPos, window.navigationData.report)
                    .then(route => {
                        // Draw updated route
                        responderNavigationRoute = L.polyline(route, {
                            color: '#10b981',
                            weight: 6,
                            opacity: 0.9,
                            dashArray: '15, 10',
                            smoothFactor: 1.0
                        }).addTo(responderMap);
                        
                        // Update navigation data
                        window.navigationData.route = route;
                        window.navigationData.currentStep = 0;
                        
                        console.log('‚úÖ Route updated from current location');
                    })
                    .catch(error => {
                        console.warn('‚ö†Ô∏è Failed to update route:', error);
                    });
            } catch (error) {
                console.error('‚ùå Error updating route:', error);
            }
        }

        // Update location on map
        async function updateLocationOnMap() {
            if (responderMap && currentLocation) {
                // Remove existing marker
                if (window.responderMarker) {
                    responderMap.removeLayer(window.responderMarker);
                }
                
                // Add new marker
                window.responderMarker = L.marker(currentLocation, {
                    icon: L.divIcon({
                        className: 'responder-marker',
                        html: '<div style="background: #3b82f6; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">R</div>',
                        iconSize: [30, 30],
                        iconAnchor: [15, 15]
                    })
                }).addTo(responderMap);
                
                // Mark as current responder marker
                window.responderMarker.responderMarker = true;
                
                // Save location to database for other responders to see
                if (responderId) {
                    try {
                        // Use proper GeoJSON format for PostGIS geometry column
                        const geoJsonPoint = {
                            type: 'Point',
                            coordinates: [currentLocation[1], currentLocation[0]] // [longitude, latitude]
                        };
                        
                        await emergencySystem.supabase
                            .from('responder')
                            .update({
                                last_location: geoJsonPoint,
                                    updated_at: new Date().toISOString()
                            })
                            .eq('id', responderId);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Failed to update responder location:', error);
                        // Don't show error to user as this is a background update
                    }
                }
            }
        }

        // Store completed assignments separately
        let completedReports = [];

        // Load completed assignments from database
        async function loadCompletedAssignments() {
            try {
                if (!responderId) {
                    console.log('‚ö†Ô∏è No responder ID, skipping completed assignments load');
                    completedReports = [];
                    return;
                }

                console.log('üîç Loading completed assignments for responder:', responderId);

                // Query completed assignments first
                const { data: assignments, error } = await emergencySystem.supabase
                    .from('assignment')
                    .select('*')
                    .eq('responder_id', responderId)
                    .eq('status', 'resolved')
                    .order('completed_at', { ascending: false });

                console.log('üìä Completed assignments query result:', {
                    assignmentsCount: assignments?.length || 0,
                    assignments: assignments,
                    error: error,
                    responderId: responderId
                });

                if (error) {
                    console.error('‚ùå Failed to load completed assignments:', error);
                    completedReports = [];
                    return;
                }

                if (!assignments || assignments.length === 0) {
                    console.log('‚ÑπÔ∏è No completed assignments found with status="resolved" for responder:', responderId);
                    
                    // Also check if there are assignments that should be resolved but aren't
                    const { data: allAssignments } = await emergencySystem.supabase
                        .from('assignment')
                        .select('id, status, report_id')
                        .eq('responder_id', responderId);
                    
                    console.log('üìã All assignments for this responder:', allAssignments);
                    completedReports = [];
                    return;
                }

                // Get report IDs and fetch reports separately
                const reportIds = assignments.map(a => a.report_id).filter(Boolean);
                const responderIds = [...new Set(assignments.map(a => a.responder_id).filter(Boolean))];
                
                // Fetch reports
                const { data: reports, error: reportsError } = await emergencySystem.supabase
                    .from('reports')
                    .select('id, message, type, status, created_at, location, reporter_name, image_path')
                    .in('id', reportIds);
                
                // Fetch responders
                const { data: responders, error: respondersError } = await emergencySystem.supabase
                    .from('responder')
                    .select('id, name, role')
                    .in('id', responderIds);
                
                // Create lookup maps
                const reportsMap = new Map((reports || []).map(r => [r.id, r]));
                const respondersMap = new Map((responders || []).map(r => [r.id, r]));
                
                // Combine assignments with reports and responders
                completedReports = assignments.map(assignment => {
                    const report = reportsMap.get(assignment.report_id);
                    const responder = respondersMap.get(assignment.responder_id);
                    
                    if (!report) {
                        console.warn('‚ö†Ô∏è Report not found for completed assignment:', assignment.id);
                        return null;
                    }
                    
                    return {
                        id: report.id,
                        message: report.message,
                        type: report.type,
                        status: assignment.status,
                        created_at: assignment.assigned_at,
                        location: report.location,
                        reporter_name: report.reporter_name,
                        image_path: report.image_path,
                        assignment_id: assignment.id,
                        assignment_status: assignment.status,
                        assigned_at: assignment.assigned_at,
                        accepted_at: assignment.accepted_at,
                        completed_at: assignment.completed_at,
                        responder_name: responder?.name,
                        responder_role: responder?.role,
                        is_assigned_to_me: true
                    };
                }).filter(report => report !== null);

                console.log('‚úÖ Loaded completed assignments:', completedReports.length);
                if (completedReports.length > 0) {
                    console.log('üìã Completed assignments:', completedReports.map(r => ({
                        id: r.id,
                        type: r.type,
                        status: r.assignment_status,
                        completed_at: r.completed_at
                    })));
                }
            } catch (error) {
                console.error('‚ùå Error loading completed assignments:', error);
                completedReports = [];
            }
        }

        // Update dashboard statistics
        async function updateDashboardStats() {
            try {
                // Load completed assignments if not already loaded
                await loadCompletedAssignments();

                // Calculate statistics from current reports (active assignments)
                const assignedCount = currentReports.filter(r => 
                    r.assignment_status === 'assigned' || 
                    r.assignment_status === 'accepted' || 
                    r.assignment_status === 'enroute' || 
                    r.assignment_status === 'on_scene'
                ).length;
                
                const completedCount = completedReports.length;
                        
                        // Calculate average response time from completed assignments
                let avgResponseTime = '--';
                const completedAssignments = completedReports.filter(r => 
                    r.assigned_at && 
                    r.completed_at
                );
                
                        if (completedAssignments.length > 0) {
                    const responseTimes = completedAssignments.map(r => {
                        const assigned = new Date(r.assigned_at);
                        const completed = new Date(r.completed_at);
                                    return (completed - assigned) / (1000 * 60); // Convert to minutes
                    }).filter(time => time > 0);
                            
                            if (responseTimes.length > 0) {
                                const avgTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
                                avgResponseTime = Math.round(avgTime) + 'min';
                            }
                }
                
                // Update the UI elements
                const assignedEl = document.getElementById('assignedReports');
                const completedEl = document.getElementById('completedReports');
                const avgTimeEl = document.getElementById('avgResponseTime');
                const assignedTrendEl = document.getElementById('assignedTrend');
                const completedTrendEl = document.getElementById('completedTrend');
                const responseTrendEl = document.getElementById('responseTrend');
                
                if (assignedEl) assignedEl.textContent = assignedCount;
                if (completedEl) completedEl.textContent = completedCount;
                if (avgTimeEl) avgTimeEl.textContent = avgResponseTime;
                if (assignedTrendEl) assignedTrendEl.textContent = `${assignedCount} active assignments`;
                if (completedTrendEl) completedTrendEl.textContent = `${completedCount} completed`;
                if (responseTrendEl) responseTrendEl.textContent = avgResponseTime !== '--' ? `Avg: ${avgResponseTime}` : 'No data';
                
                console.log(`üìä Updated stats: ${assignedCount} assigned, ${completedCount} completed, ${avgResponseTime} avg time`);
                
            } catch (error) {
                console.error('‚ùå Error updating dashboard stats:', error);
                
                // Fallback to basic stats from current reports
                const assigned = currentReports.filter(r => 
                    r.assignment_status === 'assigned' || 
                    r.assignment_status === 'accepted' || 
                    r.assignment_status === 'enroute' || 
                    r.assignment_status === 'on_scene'
                ).length;
                const completed = completedReports.length;
            
                const assignedEl = document.getElementById('assignedReports');
                const completedEl = document.getElementById('completedReports');
                const assignedTrendEl = document.getElementById('assignedTrend');
                const completedTrendEl = document.getElementById('completedTrend');
                
                if (assignedEl) assignedEl.textContent = assigned;
                if (completedEl) completedEl.textContent = completed;
                if (assignedTrendEl) assignedTrendEl.textContent = `${assigned} active assignments`;
                if (completedTrendEl) completedTrendEl.textContent = `${completed} completed`;
            }
        }

        // Update recent assignments
        function updateRecentAssignments() {
            const container = document.getElementById('recentAssignments');
            if (!container) return;
            
            // Filter out completed assignments and show only active ones
            const activeAssignments = currentReports.filter(report => 
                report.assignment_status !== 'resolved' && 
                report.assignment_status !== 'completed' &&
                report.assignment_status !== 'cancelled'
            );
            
            const recent = activeAssignments.slice(0, 5); // Show up to 5 recent active assignments
            
            if (recent.length === 0) {
                container.innerHTML = '<div class="text-center py-8"><i class="bi bi-clipboard text-4xl text-muted mb-4"></i><p class="text-muted">No active assignments</p></div>';
                return;
            }

            container.innerHTML = recent.map(report => `
                <div class="emergency-item ${report.is_assigned_to_me ? 'assigned-to-me' : ''}" onclick="selectAssignment('${report.id}')">
                    <div class="emergency-icon">
                        ${getEmergencyIcon(report.type)}
                            </div>
                    <div class="emergency-details">
                        <h4 class="emergency-title">${report.type || 'Emergency'}</h4>
                        <p class="emergency-location">${formatLocation(report.location)}</p>
                        <p class="emergency-time">Assigned: ${new Date(report.assigned_at).toLocaleString()}</p>
                        <p class="emergency-assignee">
                            <strong>To:</strong> ${report.responder_name || 'Unknown'}
                        </p>
                                </div>
                    <div class="emergency-status ${report.assignment_status}">
                        ${report.assignment_status === 'accepted' ? '' : `<span class="status-badge ${report.assignment_status}">${report.assignment_status.toUpperCase()}</span>`}
                        ${report.is_assigned_to_me ? '<span class="my-assignment-badge">MINE</span>' : ''}
                    </div>
                </div>
            `).join('');
        }

        // Update completed assignments
        function updateCompletedAssignments() {
            const container = document.getElementById('completedAssignments');
            if (!container) return;
            
            // Use completedReports which are loaded separately from database
            const completed = completedReports.slice(0, 5); // Show up to 5 completed assignments
            
            if (completed.length === 0) {
                container.innerHTML = '<div class="text-center py-8"><i class="bi bi-check-circle text-4xl text-muted mb-4"></i><p class="text-muted">No completed assignments</p></div>';
                return;
            }

            container.innerHTML = completed.map(report => `
                <div class="emergency-item completed-assignment non-clickable ${report.is_assigned_to_me ? 'assigned-to-me' : ''}">
                    <div class="emergency-icon completed-icon">
                        ${getEmergencyIcon(report.type)}
                    </div>
                    <div class="emergency-details">
                        <h4 class="emergency-title">${report.type || 'Emergency'}</h4>
                        <p class="emergency-location">${formatLocation(report.location)}</p>
                        <p class="emergency-time">Completed: ${report.completed_at ? new Date(report.completed_at).toLocaleString() : 'Unknown'}</p>
                        <p class="emergency-assignee">
                            <strong>Completed by:</strong> ${report.responder_name || 'Unknown'}
                        </p>
                        ${report.reporter_name ? `<p class="emergency-reporter"><strong>Reporter:</strong> ${report.reporter_name}</p>` : ''}
                    </div>
                    <div class="emergency-status completed">
                        <span class="status-badge resolved">RESOLVED</span>
                        ${report.is_assigned_to_me ? '<span class="my-assignment-badge">MINE</span>' : ''}
                        <div class="completion-time">
                            <small>${report.completed_at ? formatTimeAgo(report.completed_at) : ''}</small>
                        </div>
                    </div>
                            </div>
            `).join('');
        }

        // Update user info
        function updateUserInfo() {
            if (emergencySystem.user) {
                const userName = emergencySystem.user.user_metadata?.full_name || emergencySystem.user.email.split('@')[0];
                document.getElementById('userName').textContent = userName;
                
                // Use "R" for responder avatar instead of first letter of name
                document.getElementById('userAvatar').textContent = 'R';
                
                // Set appropriate role for responder
                const userRoleElement = document.getElementById('userRole');
                if (userRoleElement) {
                    userRoleElement.textContent = 'Emergency Responder';
                }
            }
        }

        // Update responder statistics
        function updateResponderStatistics() {
            try {
                // Calculate statistics for the current responder
                const myAssignments = currentReports.filter(report => 
                    report.is_assigned_to_me === true
                );
                
                const totalAssignments = myAssignments.length;
                const completedAssignments = myAssignments.filter(report => 
                    report.assignment_status === 'resolved' || 
                    report.assignment_status === 'completed'
                ).length;
                
                const activeAssignments = myAssignments.filter(report => 
                    report.assignment_status !== 'resolved' && 
                    report.assignment_status !== 'completed' &&
                    report.assignment_status !== 'cancelled'
                ).length;
                
                // Calculate success rate
                const successRate = totalAssignments > 0 ? Math.round((completedAssignments / totalAssignments) * 100) : 0;
                
                // Calculate average response time
                let avgResponseTime = '--';
                const completedWithTimes = myAssignments.filter(report => 
                    report.assignment_status === 'resolved' && 
                    report.assigned_at && 
                    report.completed_at
                );
                
                if (completedWithTimes.length > 0) {
                    const responseTimes = completedWithTimes.map(report => {
                        const assigned = new Date(report.assigned_at);
                        const completed = new Date(report.completed_at);
                        return (completed - assigned) / (1000 * 60); // Convert to minutes
                    }).filter(time => time > 0);
                    
                    if (responseTimes.length > 0) {
                        const avgTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
                        avgResponseTime = Math.round(avgTime) + 'min';
                    }
                }
                
                // Update the UI elements
                const totalEl = document.getElementById('totalAssignments');
                const completedEl = document.getElementById('totalCompleted');
                const successEl = document.getElementById('successRate');
                const activeEl = document.getElementById('activeAssignments');
                const avgTimeEl = document.getElementById('avgResponseTime');
                
                if (totalEl) totalEl.textContent = totalAssignments;
                if (completedEl) completedEl.textContent = completedAssignments;
                if (successEl) successEl.textContent = successRate + '%';
                if (activeEl) activeEl.textContent = activeAssignments;
                if (avgTimeEl) avgTimeEl.textContent = avgResponseTime;
                
                console.log(`üìä Responder stats updated: ${totalAssignments} total, ${completedAssignments} completed, ${activeAssignments} active, ${successRate}% success rate`);
                
            } catch (error) {
                console.error('‚ùå Error updating responder statistics:', error);
            }
        }

        // Toggle availability status
        async function toggleAvailability() {
            try {
                isAvailable = !isAvailable;
                
                if (!responderId) {
                    console.warn('‚ö†Ô∏è No responder ID available');
                return;
            }
            
                const { error } = await emergencySystem.supabase
                    .from('responder')
                    .update({ is_available: isAvailable })
                    .eq('id', responderId);
                
                if (error) {
                    console.error('‚ùå Failed to update availability:', error);
                    emergencySystem.showError('Failed to update availability');
                    return;
                }
                
                updateStatusToggle();
                emergencySystem.showSuccess(`Status updated to ${isAvailable ? 'Available' : 'Unavailable'}`);
                
            } catch (error) {
                console.error('‚ùå Error updating availability:', error);
                emergencySystem.showError('Failed to update availability');
            }
        }

        // Update status toggle UI
        function updateStatusToggle() {
            const toggle = document.getElementById('availabilityToggle');
            const statusText = document.getElementById('currentStatus');
            
            if (toggle) {
                toggle.classList.toggle('active', isAvailable);
            }
            
            if (statusText) {
                statusText.textContent = isAvailable ? 'Available' : 'Unavailable';
            }
        }

        // Show section
        function showSection(sectionName) {
            // Hide all sections
            document.querySelectorAll('.admin-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all nav items
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show selected section
            const section = document.getElementById(sectionName + '-section');
            if (section) {
                section.classList.add('active');
            }
            
            // Add active class to nav item
            const navItem = document.getElementById('nav-' + sectionName);
            if (navItem) {
                navItem.classList.add('active');
            }
            
            // Load section-specific data
            if (sectionName === 'assignments') {
                displayAssignments();
            } else if (sectionName === 'map') {
                // Show navigation controls when map is selected
                const navigationControls = document.getElementById('navigationControls');
                if (navigationControls) {
                    navigationControls.style.display = 'block';
                }
                
                // Initialize map if not already done
                if (!responderMap) {
                    console.log('üó∫Ô∏è Map not initialized, initializing now...');
                    initializeMap();
                } else {
                    console.log('üó∫Ô∏è Map already initialized, refreshing...');
                    // Just refresh the existing map
                    setTimeout(async () => {
                        if (responderMap) {
                            responderMap.invalidateSize();
                            await updateMapView();
                            // Load other responders
                            if (responderId) {
                                await loadOtherResponders();
                            }
                            console.log('‚úÖ Map refreshed for map view');
                        }
                    }, 100);
                }
            } else {
                // Hide navigation controls for other sections
                const navigationControls = document.getElementById('navigationControls');
                if (navigationControls) {
                    navigationControls.style.display = 'none';
                }
            }
        }

        // Store other responders' markers and routes
        let otherResponderMarkers = [];
        let otherResponderRoutes = [];

        // Load and display other responders on map
        async function loadOtherResponders() {
            try {
                console.log('üë• Loading other responders...');
                
                // Fetch all active responders
                const { data: responders, error } = await emergencySystem.supabase
                    .from('responder')
                    .select('id, name, role, is_available, status, last_location')
                    .eq('is_available', true)
                    .neq('id', responderId); // Exclude current responder
                
                if (error) {
                    console.error('‚ùå Failed to load other responders:', error);
                    return;
                }
                
                console.log(`‚úÖ Loaded ${responders.length} other responders`);
                
                // Clear existing other responder markers
                otherResponderMarkers.forEach(marker => {
                    if (responderMap) {
                        responderMap.removeLayer(marker);
                    }
                });
                otherResponderMarkers = [];
                
                // Clear existing other responder routes
                otherResponderRoutes.forEach(route => {
                    if (responderMap) {
                        responderMap.removeLayer(route);
                    }
                });
                otherResponderRoutes = [];
                
                // Display each responder
                for (const responder of responders) {
                    // Get responder's active assignments
                    const { data: assignments } = await emergencySystem.supabase
                        .from('assignment')
                        .select(`
                            *,
                            reports:reports!assignment_report_id_fkey (
                                id,
                                location,
                                type
                            )
                        `)
                        .eq('responder_id', responder.id)
                        .in('status', ['assigned', 'accepted', 'enroute', 'on_scene'])
                        .order('created_at', { ascending: false })
                        .limit(1); // Get most recent active assignment
                    
                    if (assignments && assignments.length > 0) {
                        const assignment = assignments[0];
                        const report = assignment.reports;
                        
                        if (report && report.location) {
                            await displayResponderWithRoute(responder, assignment, report);
                        }
                    } else if (responder.last_location) {
                        // Show responder location even if no active assignment
                        displayResponderLocation(responder);
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Error loading other responders:', error);
            }
        }

        // Display responder with their route to assignment
        async function displayResponderWithRoute(responder, assignment, report) {
            try {
                let responderLocation = null;
                let reportLocation = null;
                
                // Parse responder location
                if (responder.last_location) {
                    if (typeof responder.last_location === 'string') {
                        const loc = JSON.parse(responder.last_location);
                        responderLocation = [loc.lat || loc.latitude, loc.lng || loc.longitude];
                    } else if (responder.last_location.lat && responder.last_location.lng) {
                        responderLocation = [responder.last_location.lat, responder.last_location.lng];
                    }
                }
                
                // Parse report location
                if (report.location) {
                    if (typeof report.location === 'string') {
                        const loc = JSON.parse(report.location);
                        reportLocation = [loc.latitude || loc.lat, loc.longitude || loc.lng];
                    } else if (report.location.latitude && report.location.longitude) {
                        reportLocation = [report.location.latitude, report.location.longitude];
                    }
                }
                
                if (!responderLocation || !reportLocation) {
                    console.warn('‚ö†Ô∏è Missing location data for responder:', responder.id);
                    return;
                }
                
                // Add responder marker
                const responderMarker = L.marker(responderLocation, {
                    icon: L.divIcon({
                        className: 'other-responder-marker',
                        html: `<div style="background: #10b981; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 14px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-weight: bold;">üë§</div>`,
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    })
                }).addTo(responderMap);
                
                responderMarker.responderMarker = true;
                responderMarker.bindPopup(`
                    <div style="min-width: 250px;">
                        <div style="background: #10b981; color: white; padding: 10px; margin: -10px -10px 10px -10px; border-radius: 5px 5px 0 0;">
                            <h4 style="margin: 0; font-size: 16px;">üë§ ${responder.name}</h4>
                        </div>
                        <div style="padding: 5px 0;">
                            <p><strong>Role:</strong> ${responder.role || 'Responder'}</p>
                            <p><strong>Status:</strong> <span style="color: #10b981; font-weight: bold;">${assignment.status.toUpperCase()}</span></p>
                            <p><strong>Assignment:</strong> ${report.type || 'Emergency'}</p>
                            <p><strong>En Route:</strong> Yes</p>
                        </div>
                        <div style="margin-top: 10px; display: flex; gap: 8px;">
                            <button onclick="navigateToResponder('${responder.id}', '${responderLocation[0]}', '${responderLocation[1]}', '${responder.name}')" style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 13px; flex: 1;">
                                <i class="bi bi-navigation"></i> Navigate
                            </button>
                        </div>
                    </div>
                `);
                
                // Store responder data for navigation
                responderMarker.responderData = {
                    id: responder.id,
                    name: responder.name,
                    location: responderLocation
                };
                
                otherResponderMarkers.push(responderMarker);
                
                // Draw route line from responder to assignment
                const routeLine = L.polyline([responderLocation, reportLocation], {
                    color: '#10b981',
                    weight: 4,
                    opacity: 0.6,
                    dashArray: '10, 5'
                }).addTo(responderMap);
                
                otherResponderRoutes.push(routeLine);
                
                // Add assignment marker if not already added
                if (report.location) {
                    const existingMarker = Array.from(responderMap._layers).find(layer => {
                        if (layer instanceof L.Marker && layer.assignmentMarker) {
                            const markerLatLng = layer.getLatLng();
                            return Math.abs(markerLatLng.lat - reportLocation[0]) < 0.0001 &&
                                   Math.abs(markerLatLng.lng - reportLocation[1]) < 0.0001;
                        }
                        return false;
                    });
                    
                    if (!existingMarker) {
                        const assignmentMarker = L.marker(reportLocation, {
                            icon: L.divIcon({
                                className: 'assignment-marker',
                                html: `<div style="background: ${getEmergencyColor(report.type)}; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">${getEmergencyIcon(report.type)}</div>`,
                                iconSize: [30, 30],
                                iconAnchor: [15, 15]
                            })
                        }).addTo(responderMap);
                        
                        assignmentMarker.assignmentMarker = true;
                        assignmentMarker.bindPopup(`
                            <div style="min-width: 200px;">
                                <div style="background: ${getEmergencyColor(report.type)}; color: white; padding: 10px; margin: -10px -10px 10px -10px; border-radius: 5px 5px 0 0;">
                                    <h4 style="margin: 0; font-size: 16px;">${report.type.toUpperCase()} EMERGENCY</h4>
                                </div>
                                <div style="padding: 5px 0;">
                                    <p><strong>Assigned to:</strong> ${responder.name}</p>
                                    <p><strong>Status:</strong> ${assignment.status.toUpperCase()}</p>
                                </div>
                            </div>
                        `);
                    }
                }
                
                console.log(`‚úÖ Displayed responder ${responder.name} with route`);
                
            } catch (error) {
                console.error('‚ùå Error displaying responder route:', error);
            }
        }

        // Display responder location without route
        function displayResponderLocation(responder) {
            try {
                let responderLocation = null;
                
                if (responder.last_location) {
                    if (typeof responder.last_location === 'string') {
                        const loc = JSON.parse(responder.last_location);
                        responderLocation = [loc.lat || loc.latitude, loc.lng || loc.longitude];
                    } else if (responder.last_location.lat && responder.last_location.lng) {
                        responderLocation = [responder.last_location.lat, responder.last_location.lng];
                    }
                }
                
                if (!responderLocation) return;
                
                const responderMarker = L.marker(responderLocation, {
                    icon: L.divIcon({
                        className: 'other-responder-marker',
                        html: `<div style="background: #6b7280; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 14px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-weight: bold;">üë§</div>`,
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    })
                }).addTo(responderMap);
                
                responderMarker.responderMarker = true;
                responderMarker.bindPopup(`
                    <div style="min-width: 250px;">
                        <div style="background: #6b7280; color: white; padding: 10px; margin: -10px -10px 10px -10px; border-radius: 5px 5px 0 0;">
                            <h4 style="margin: 0; font-size: 16px;">üë§ ${responder.name}</h4>
                        </div>
                        <div style="padding: 5px 0;">
                            <p><strong>Role:</strong> ${responder.role || 'Responder'}</p>
                            <p><strong>Status:</strong> <span style="color: #10b981; font-weight: bold;">AVAILABLE</span></p>
                            <p><strong>Assignment:</strong> None</p>
                        </div>
                        <div style="margin-top: 10px; display: flex; gap: 8px;">
                            <button onclick="navigateToResponder('${responder.id}', '${responderLocation[0]}', '${responderLocation[1]}', '${responder.name}')" style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 13px; flex: 1;">
                                <i class="bi bi-navigation"></i> Navigate
                            </button>
                        </div>
                    </div>
                `);
                
                // Store responder data for navigation
                responderMarker.responderData = {
                    id: responder.id,
                    name: responder.name,
                    location: responderLocation
                };
                
                otherResponderMarkers.push(responderMarker);
                
            } catch (error) {
                console.error('‚ùå Error displaying responder location:', error);
            }
        }

        // Update map view
        async function updateMapView() {
            if (responderMap && currentReports.length > 0) {
                // Clear existing emergency markers (but keep other responder markers)
                responderMap.eachLayer(layer => {
                    if (layer instanceof L.Marker && !layer.assignmentMarker && !layer.responderMarker) {
                        responderMap.removeLayer(layer);
                    }
                });
                
                // Filter out resolved/completed assignments - only show active assignments on map
                const activeReports = currentReports.filter(report => 
                    report.assignment_status !== 'resolved' && 
                    report.assignment_status !== 'completed' &&
                    report.assignment_status !== 'cancelled'
                );
                
                console.log(`üó∫Ô∏è Showing ${activeReports.length} active assignments on map (filtered out ${currentReports.length - activeReports.length} resolved assignments)`);
                
                // Add markers for each active report only
                activeReports.forEach(report => {
                    if (report.location && typeof report.location === 'string') {
                        try {
                            const locationData = JSON.parse(report.location);
                            const marker = L.marker([locationData.latitude, locationData.longitude], {
                                icon: L.divIcon({
                                    className: 'emergency-marker',
                                    html: `<div style="background: ${getEmergencyColor(report.type)}; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">${getEmergencyIcon(report.type)}</div>`,
                                    iconSize: [30, 30],
                                    iconAnchor: [15, 15]
                                })
                            }).addTo(responderMap);
                            
                    // Enhanced popup with detailed information and navigation
                    const popupContent = `
                        <div class="map-popup" style="min-width: 300px;">
                            <div class="popup-header" style="background: ${getEmergencyColor(report.type)}; color: white; padding: 10px; margin: -10px -10px 10px -10px; border-radius: 5px 5px 0 0;">
                                <h4 style="margin: 0; font-size: 18px;">${report.type.toUpperCase()} EMERGENCY</h4>
                        </div>
                            
                            <div class="popup-content">
                                <div class="emergency-info">
                                    <p><strong>üìä Status:</strong> <span class="badge badge-${report.status}" style="background: #3b82f6; color: white; padding: 2px 8px; border-radius: 3px; font-size: 12px;">${report.status.toUpperCase()}</span></p>
                                    <p><strong>üìç Location:</strong> ${formatLocation(report.location)}</p>
                                    <p><strong>‚è∞ Time:</strong> ${new Date(report.created_at).toLocaleString()}</p>
                                    <p><strong>üìù Description:</strong> ${report.message || 'No description provided'}</p>
                                    ${report.image_path ? `<p><strong>üì∑ Photo:</strong> <img src="${report.image_path}" alt="Emergency Photo" style="max-width: 80px; max-height: 60px; width: auto; height: auto; border-radius: 4px; cursor: pointer; margin-left: 5px; object-fit: cover;" onclick="openImageModal('${report.image_path}')"></p>` : ''}
                                    ${report.reporter_name ? `<p><strong>üë§ Reporter:</strong> ${report.reporter_name}</p>` : ''}
                                </div>
                                
                                <div class="popup-actions" style="margin-top: 15px; display: flex; gap: 10px;">
                                    <button onclick="navigateToReport('${report.id}')" class="btn btn-primary" style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                        <i class="bi bi-navigation"></i> Navigate
                                    </button>
                                    <button onclick="viewReportDetails('${report.id}')" class="btn btn-secondary" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                        <i class="bi bi-eye"></i> View Details
                                    </button>
                                </div>
                                
                                <div class="route-info" style="margin-top: 10px; padding: 10px; background: #f3f4f6; border-radius: 4px; font-size: 12px;">
                                    <p><strong>üõ£Ô∏è Safe Route Available:</strong> Yes</p>
                                    <p><strong>‚è±Ô∏è Estimated Time:</strong> 15-20 minutes</p>
                                    <p><strong>üöó Distance:</strong> ~5.2 km</p>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                        } catch (e) {
                            console.warn('Failed to parse location for report:', report.id);
                        }
                    }
                });
                
                // Add responder location if available
                await updateLocationOnMap();
                
                // Load and display other responders
                if (responderId) {
                    await loadOtherResponders();
                }
            }
        }

        // Show navigation panel
        function showNavigationPanel() {
            if (!window.navigationData) return;
            
            const existingPanel = document.getElementById('navigationPanel');
            if (existingPanel) {
                existingPanel.remove();
            }
            
            const panel = document.createElement('div');
            panel.id = 'navigationPanel';
            panel.className = 'navigation-panel';
            panel.innerHTML = `
                <div class="navigation-header" style="background: #3b82f6; color: white; padding: 15px; border-radius: 10px 10px 0 0;">
                    <h3 class="navigation-title" style="margin: 0; font-size: 18px;">üß≠ Safe Navigation Active</h3>
                    <button class="navigation-close" onclick="closeNavigationPanel()" style="background: none; border: none; color: white; font-size: 20px; cursor: pointer;">√ó</button>
                </div>
                <div class="navigation-body" style="padding: 20px;">
                    <div id="navigationContent">
                        <div style="margin-bottom: 15px;">
                            <strong>üìç Destination:</strong> <span id="navDestination">${window.navigationData.report.type} Emergency</span>
                </div>
                        <div style="margin-bottom: 15px;">
                            <strong>‚è±Ô∏è Estimated Time:</strong> <span id="navTime">15-20 minutes</span>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <strong>üöó Distance:</strong> <span id="navDistance">~5.2 km</span>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <strong>üõ£Ô∏è Route Status:</strong> <span style="color: #10b981; font-weight: bold;">Safe Route</span>
                        </div>
                        
                        <div style="margin-top: 20px;">
                            <h4 style="margin: 0 0 10px 0;">üìã Navigation Steps</h4>
                            <div id="stepsList" style="max-height: 200px; overflow-y: auto; background: #f9fafb; padding: 10px; border-radius: 5px;">
                                <div style="padding: 8px; background: #10b981; color: white; border-radius: 4px; margin-bottom: 5px;">
                                    <strong>Step 1:</strong> Start from current location
                                </div>
                                <div style="padding: 8px; background: #e5e7eb; border-radius: 4px; margin-bottom: 5px;">
                                    <strong>Step 2:</strong> Head north on main road
                                </div>
                                <div style="padding: 8px; background: #e5e7eb; border-radius: 4px; margin-bottom: 5px;">
                                    <strong>Step 3:</strong> Turn right at intersection
                                </div>
                                <div style="padding: 8px; background: #e5e7eb; border-radius: 4px;">
                                    <strong>Step 4:</strong> Arrive at emergency location
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 15px; padding: 10px; background: #f0f9ff; border-radius: 5px; font-size: 12px;">
                            <strong>üõ°Ô∏è Safety Tips:</strong>
                            <ul style="margin: 5px 0; padding-left: 20px;">
                                <li>Follow the green route markers</li>
                                <li>Check for hazards at each waypoint</li>
                                <li>Report any route issues immediately</li>
                            </ul>
                        </div>
                    </div>
                    <div class="navigation-controls" style="margin-top: 20px; display: flex; gap: 10px;">
                        <button class="navigation-btn" onclick="previousInstruction()" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">‚Üê Previous</button>
                        <button class="navigation-btn primary" onclick="nextInstruction()" style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Next ‚Üí</button>
                    <button class="navigation-btn" onclick="markAssignmentComplete()" style="background: #059669; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                        <i class="bi bi-check-circle"></i> Mark Complete
                    </button>
                        <button class="navigation-btn" onclick="endNavigation()" style="background: #ef4444; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">End Navigation</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(panel);
            showNextInstruction();
        }
        
        // Show real-world navigation panel with OSRM data
        function showRealWorldNavigationPanel() {
            if (!window.navigationData) return;
            
            const panel = document.getElementById('realWorldNavigation');
            if (!panel) return;
            
            panel.style.display = 'block';
            
            const content = document.getElementById('realWorldNavigationContent');
            if (!content) return;
            
            const destinationText = window.navigationData.isNavigatingToResponder 
                ? window.navigationData.report.message || 'Responder Location'
                : `${window.navigationData.report.type} Emergency`;
            
            content.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <strong>üìç Destination:</strong> <span id="navDestination">${destinationText}</span>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>‚è±Ô∏è Estimated Time:</strong> <span id="navTime">${window.navigationData.totalDuration}</span>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>üöó Distance:</strong> <span id="navDistance">${window.navigationData.totalDistance}</span>
                </div>
                <div style="margin-bottom: 15px;">
                    <strong>üõ£Ô∏è Route Status:</strong> <span style="color: #10b981; font-weight: bold;">Real-World Route</span>
                </div>
                
                <div style="margin-top: 20px;">
                    <h4 style="margin: 0 0 10px 0;">üìã Real-World Directions</h4>
                    <div id="stepsList" style="max-height: 200px; overflow-y: auto; background: #f9fafb; padding: 10px; border-radius: 5px;">
                        ${window.navigationData.instructions.map((step, index) => `
                            <div class="navigation-step ${index === 0 ? 'current' : ''}" style="padding: 10px; background: ${index === 0 ? '#10b981' : '#e5e7eb'}; color: ${index === 0 ? 'white' : 'black'}; border-radius: 4px; margin-bottom: 8px; border-left: 4px solid ${index === 0 ? '#059669' : '#d1d5db'};">
                                <div class="navigation-instruction" style="font-weight: bold; margin-bottom: 5px;">Step ${index + 1}: ${step.instruction}</div>
                                <div class="navigation-distance" style="font-size: 12px; opacity: 0.8;">${Math.round(step.distance)}m ‚Ä¢ ${Math.round(step.duration/60)}min</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background: #f0f9ff; border-radius: 5px; font-size: 12px;">
                    <strong>üó∫Ô∏è Real-World Features:</strong>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li>Real road data from OpenStreetMap</li>
                        <li>Accurate turn-by-turn directions</li>
                        <li>Street names and landmarks</li>
                        <li>OSRM routing engine</li>
                        ${window.navigationData.isNavigatingToResponder ? '<li>Navigate to other responders for coordination</li>' : '<li>Other responders visible on map</li>'}
                    </ul>
                </div>
                
                <div class="navigation-controls" style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="navigation-btn" onclick="previousInstruction()" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">‚Üê Previous</button>
                    <button class="navigation-btn primary" onclick="nextInstruction()" style="background: #10b981; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Next ‚Üí</button>
                    ${!window.navigationData.isNavigatingToResponder ? `
                    <button class="navigation-btn" onclick="markAssignmentComplete()" style="background: #059669; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                        <i class="bi bi-check-circle"></i> Mark Complete
                    </button>
                    ` : ''}
                    <button class="navigation-btn" onclick="endNavigation()" style="background: #ef4444; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">End Navigation</button>
                </div>
            `;
            
            showNextInstruction();
        }

        // Show next instruction
        function showNextInstruction() {
            if (!window.navigationData) return;
            
            const content = document.getElementById('navigationContent');
            if (!content) return;
            
            const currentStep = window.navigationData.currentStep;
            const instructions = window.navigationData.instructions;
            
            if (currentStep >= instructions.length) {
                content.innerHTML = '<div class="navigation-step"><div class="navigation-instruction">You have arrived at your destination!</div></div>';
                return;
            }
            
            const instruction = instructions[currentStep];
            const instructionText = instruction.instruction;
            const distance = instruction.distance > 0 ? `${(instruction.distance / 1000).toFixed(1)} km` : '';
            
            content.innerHTML = `
                <div class="navigation-step current">
                    <div class="navigation-instruction">${instructionText}</div>
                    <div class="navigation-distance">${distance}</div>
                </div>
            `;
                
                // Show instruction in browser notification
                if (Notification.permission === 'granted') {
                    new Notification('Navigation Instruction', {
                        body: instructionText,
                        icon: '/favicon.ico'
                    });
            }
        }

        // Next instruction
        async function nextInstruction() {
            if (!window.navigationData) return;
            
            window.navigationData.currentStep++;
            if (window.navigationData.currentStep >= window.navigationData.instructions.length) {
                const destinationType = window.navigationData.isNavigatingToResponder ? 'responder location' : 'destination';
                emergencySystem.showSuccess(`You have arrived at the ${destinationType}!`);
                
                // Only auto-mark assignment complete if navigating to emergency, not to responder
                if (!window.navigationData.isNavigatingToResponder) {
                    await autoMarkAssignmentComplete();
                }
                
                endNavigation();
                return;
            }
            
            showNextInstruction();
        }

        // Previous instruction
        function previousInstruction() {
            if (!window.navigationData || window.navigationData.currentStep <= 0) return;
            
            window.navigationData.currentStep--;
            showNextInstruction();
        }

        // Mark assignment as complete manually
        async function markAssignmentComplete() {
            if (!window.navigationData || !window.navigationData.report) {
                emergencySystem.showError('No active assignment to complete');
                return;
            }
            
            const report = window.navigationData.report;
            const assignmentId = report.assignment_id;
            
            if (!assignmentId) {
                emergencySystem.showError('Assignment ID not found');
                return;
            }
            
            try {
                console.log('‚úÖ Marking assignment as complete:', assignmentId);
                
                // Show confirmation dialog
                const confirmed = confirm(
                    `Are you sure you want to mark this assignment as complete?\n\n` +
                    `Assignment: ${report.type} Emergency\n` +
                    `Location: ${formatLocation(report.location)}\n\n` +
                    `This will update the assignment status to "resolved".`
                );
                
                if (!confirmed) {
                    return;
                }
                
                // Update assignment status to resolved
                await updateAssignmentStatus(assignmentId, 'resolved');
                
                // End navigation
                endNavigation();
                
                // Show success message
                emergencySystem.showSuccess('Assignment marked as complete! Great job!');
                
                // Refresh dashboard data
                await loadDashboardData();
                
            } catch (error) {
                console.error('‚ùå Error marking assignment complete:', error);
                emergencySystem.showError('Failed to mark assignment as complete');
            }
        }

        // Auto mark assignment as complete when navigation finishes
        async function autoMarkAssignmentComplete() {
            if (!window.navigationData || !window.navigationData.report) {
                console.log('‚ö†Ô∏è No active assignment to auto-complete');
                return;
            }
            
            const report = window.navigationData.report;
            const assignmentId = report.assignment_id;
            
            if (!assignmentId) {
                console.log('‚ö†Ô∏è Assignment ID not found for auto-completion');
                return;
            }
            
            try {
                console.log('‚úÖ Auto-marking assignment as complete:', assignmentId);
                
                // Update assignment status to resolved (this will also update the report status)
                await updateAssignmentStatus(assignmentId, 'resolved');
                
                // Show success message
                emergencySystem.showSuccess('Assignment automatically marked as complete! Great job!');
                
                // Refresh dashboard data
                await loadDashboardData();
                
            } catch (error) {
                console.error('‚ùå Error auto-marking assignment complete:', error);
                emergencySystem.showError('Failed to auto-mark assignment as complete');
            }
        }


        // End navigation
        function endNavigation() {
            console.log('üõë Ending navigation...');
            
            // Clear navigation data
            window.navigationData = null;
            
            // Remove navigation panel
            const navigationPanel = document.getElementById('navigationPanel');
            if (navigationPanel) {
                navigationPanel.remove();
            }
            
            // Remove real-world navigation panel
            const realWorldPanel = document.getElementById('realWorldNavigation');
            if (realWorldPanel) {
                realWorldPanel.style.display = 'none';
            }
            
            // Remove routing control
            if (routingControl && responderMap) {
                responderMap.removeControl(routingControl);
                routingControl = null;
            }
            
            // Remove navigation route
            if (responderNavigationRoute && responderMap) {
                responderMap.removeLayer(responderNavigationRoute);
                responderNavigationRoute = null;
            }
            
            // Clear assignment markers
            if (responderMap) {
                responderMap.eachLayer(layer => {
                    if (layer.assignmentMarker) {
                        responderMap.removeLayer(layer);
                    }
                });
            }
            
            // Stop location tracking
            if (window.locationWatchId) {
                navigator.geolocation.clearWatch(window.locationWatchId);
                window.locationWatchId = null;
            }
            
            emergencySystem.showSuccess('Navigation ended');
            console.log('‚úÖ Navigation ended successfully');
        }

        // Close navigation panel
        function closeNavigationPanel() {
            const navigationPanel = document.getElementById('navigationPanel');
            if (navigationPanel) {
                navigationPanel.remove();
            }
        }
        
        // Close real-world navigation panel
        function closeRealWorldNavigation() {
            const panel = document.getElementById('realWorldNavigation');
            if (panel) {
                panel.style.display = 'none';
            }
        }

        // Create enhanced route with realistic waypoints
        function createEnhancedRoute(from, to) {
            const lat1 = from[0];
            const lon1 = from[1];
            const lat2 = to[0];
            const lon2 = to[1];
            
            const distance = calculateDistance(from, to);
            const numPoints = Math.max(3, Math.min(10, Math.floor(distance / 1000)));
            
            const waypoints = [];
            
            for (let i = 1; i < numPoints; i++) {
                const ratio = i / numPoints;
                const lat = lat1 + (lat2 - lat1) * ratio;
                const lon = lon1 + (lon2 - lon1) * ratio;
                
                const variation = Math.min(0.005, distance / 100000);
                const latVariation = (Math.random() - 0.5) * variation;
                const lonVariation = (Math.random() - 0.5) * variation;
                
                const curveFactor = Math.sin(ratio * Math.PI) * 0.002;
                const latCurve = (Math.random() - 0.5) * curveFactor;
                const lonCurve = (Math.random() - 0.5) * curveFactor;
                
                waypoints.push([
                    lat + latVariation + latCurve, 
                    lon + lonVariation + lonCurve
                ]);
            }
            
            return [from, ...waypoints, to];
        }

        // Create navigation steps for the route
        function createNavigationSteps(route) {
            const steps = [];
            const totalDistance = calculateDistance(route[0], route[route.length - 1]);
            
            steps.push({
                instruction: 'Start navigation to emergency location',
                distance: 0,
                way_points: [0, 0]
            });
            
            for (let i = 1; i < route.length - 1; i++) {
                const segmentDistance = calculateDistance(route[i-1], route[i]);
                const instruction = getRouteInstruction(route[i-1], route[i], route[i+1]);
                
                steps.push({
                    instruction: instruction,
                    distance: segmentDistance,
                    way_points: [i-1, i]
                });
            }
            
            steps.push({
                instruction: 'You have arrived at the emergency location',
                distance: 0,
                way_points: [route.length - 1, route.length - 1]
            });
            
            return steps;
        }

        // Get route instruction based on direction changes
        function getRouteInstruction(prev, current, next) {
            if (!next) return 'Continue to destination';
            
            const bearing1 = calculateBearing(prev, current);
            const bearing2 = calculateBearing(current, next);
            const angleDiff = bearing2 - bearing1;
            
            if (Math.abs(angleDiff) < 30) {
                return 'Continue straight ahead';
            } else if (angleDiff > 30 && angleDiff < 150) {
                return 'Turn right and continue';
            } else if (angleDiff < -30 && angleDiff > -150) {
                return 'Turn left and continue';
            } else if (angleDiff > 150 || angleDiff < -150) {
                return 'Make a U-turn and continue';
            } else {
                return 'Continue following the route';
            }
        }

        // Calculate bearing between two points
        function calculateBearing(point1, point2) {
            const lat1 = point1[0] * Math.PI / 180;
            const lat2 = point2[0] * Math.PI / 180;
            const deltaLon = (point2[1] - point1[1]) * Math.PI / 180;
            
            const y = Math.sin(deltaLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);
            
            return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
        }

        // Calculate distance between two points
        function calculateDistance(point1, point2) {
            const R = 6371e3;
            const œÜ1 = point1[0] * Math.PI / 180;
            const œÜ2 = point2[0] * Math.PI / 180;
            const ŒîœÜ = (point2[0] - point1[0]) * Math.PI / 180;
            const ŒîŒª = (point2[1] - point1[1]) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                    Math.cos(œÜ1) * Math.cos(œÜ2) *
                    Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Set up real-time notifications
        async function setupNotifications() {
            try {
                if (notificationChannel) {
                    notificationChannel.unsubscribe();
                }
                
                notificationChannel = emergencySystem.supabase
                    .channel('responder-notifications')
                    .on('postgres_changes', {
                        event: '*',
                        schema: 'public',
                        table: 'reports'
                    }, (payload) => {
                        console.log('üì¢ Real-time update (reports):', payload);
                        // Reload data when reports change
                        loadAssignedReports();
                        updateDashboardStats();
                    })
                    .on('postgres_changes', {
                        event: '*',
                        schema: 'public',
                        table: 'assignment'
                    }, (payload) => {
                        console.log('üì¢ Real-time update (assignment):', payload);
                        // Only reload if this assignment is for the current responder
                        if (responderId && payload.new?.responder_id === responderId || payload.old?.responder_id === responderId) {
                            console.log('üîÑ Assignment changed for current responder, reloading...');
                            loadAssignedReports();
                            loadCompletedAssignments();
                            updateDashboardStats();
                        }
                    })
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'notifications',
                        filter: `target_type=eq.responder,target_id=eq.${responderId || ''}`
                    }, (payload) => {
                        console.log('üîî New notification received:', payload.new);
                        if (payload.new) {
                            showNotificationToast(payload.new);
                            syncNotifications();
                        }
                    })
                    .subscribe();
                
                console.log('‚úÖ Real-time notifications enabled');
            } catch (error) {
                console.error('‚ùå Failed to setup notifications:', error);
            }
        }

        // Sync notifications for current responder
        async function syncNotifications() {
            try {
                const { data, error } = await emergencySystem.supabase.functions.invoke(
                    'sync-notifications',
                    {
                        body: { 
                            limit: 20, 
                            unreadOnly: false 
                        }
                    }
                );

                if (error) throw error;
                
                console.log('‚úÖ Synced notifications:', data);
                return data;
            } catch (error) {
                console.error('‚ùå Failed to sync notifications:', error);
                return null;
            }
        }

        // Show notification toast
        function showNotificationToast(notification) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: white;
                border-left: 4px solid #28a745;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                max-width: 400px;
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
            `;
            
            toast.innerHTML = `
                <div style="display: flex; align-items: start; gap: 10px;">
                    <div style="font-size: 24px;">üîî</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; margin-bottom: 5px;">${notification.title || 'New Notification'}</div>
                        <div style="font-size: 14px; color: #666;">${notification.message || ''}</div>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" style="border: none; background: none; cursor: pointer; font-size: 20px; color: #999;">&times;</button>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 5000);
        }

        // Utility functions
        function getEmergencyIcon(type) {
            if (!type || typeof type !== 'string') {
                return '‚ö†Ô∏è';
            }
            
            const icons = {
                fire: 'üî•',
                medical: 'üè•',
                accident: 'üöó',
                flood: 'üåä',
                earthquake: 'üåç',
                storm: '‚õàÔ∏è',
                other: '‚ö†Ô∏è',
                unknown: '‚ùì'
            };
            return icons[type.toLowerCase()] || '‚ö†Ô∏è';
        }

        function formatTimeAgo(dateString) {
            if (!dateString) return '';
            
            try {
                const date = new Date(dateString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);
                
                if (diffMins < 1) return 'Just now';
                if (diffMins < 60) return `${diffMins} ${diffMins === 1 ? 'minute' : 'minutes'} ago`;
                if (diffHours < 24) return `${diffHours} ${diffHours === 1 ? 'hour' : 'hours'} ago`;
                if (diffDays < 7) return `${diffDays} ${diffDays === 1 ? 'day' : 'days'} ago`;
                
                return date.toLocaleDateString();
            } catch (error) {
                return '';
            }
        }

        function getEmergencyColor(type) {
            if (!type || typeof type !== 'string') {
                return '#ef4444'; // Default red
            }
            
            const colors = {
                fire: '#ef4444',      // Red for fire
                medical: '#10b981',   // Green for medical
                accident: '#f59e0b',  // Orange for accidents
                flood: '#3b82f6',     // Blue for floods (water color)
                earthquake: '#8b5cf6', // Purple for earthquakes
                storm: '#6366f1',     // Indigo for storms
                other: '#6b7280',     // Gray for other
                unknown: '#6b7280'    // Gray for unknown
            };
            return colors[type.toLowerCase()] || '#ef4444';
        }

        function formatLocation(location) {
            if (!location) return 'Unknown Location';
            
            console.log('üìç Formatting location:', location);
            
            if (typeof location === 'string') {
                if (location.startsWith('{')) {
                try {
                    const locationData = JSON.parse(location);
                        console.log('üìç Parsed location data:', locationData);
                        
                    if (locationData.address && locationData.address !== 'Location detected') {
                        return locationData.address;
                        } else if (locationData.formatted_address && locationData.formatted_address !== 'Location detected') {
                            return locationData.formatted_address;
                    } else if (locationData.latitude && locationData.longitude) {
                        return `${locationData.latitude.toFixed(6)}, ${locationData.longitude.toFixed(6)}`;
                        } else {
                            return 'Location detected';
                    }
                } catch (e) {
                    console.warn('Failed to parse location JSON:', e);
                        return location;
                    }
                } else {
                    // It's a plain string, return as is
                    return location;
                }
            } else if (typeof location === 'object') {
                // Handle object format
                if (location.address && location.address !== 'Location detected') {
                    return location.address;
                } else if (location.formatted_address && location.formatted_address !== 'Location detected') {
                    return location.formatted_address;
                } else if (location.latitude && location.longitude) {
                    return `${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}`;
                } else {
                    return 'Location detected';
                }
            }
            
            return location || 'Unknown Location';
        }

        // Format time ago for completed assignments
        function formatTimeAgo(dateString) {
            if (!dateString) return '';
            
            const now = new Date();
            const date = new Date(dateString);
            const diffInSeconds = Math.floor((now - date) / 1000);
            
            if (diffInSeconds < 60) {
                return 'Just now';
            } else if (diffInSeconds < 3600) {
                const minutes = Math.floor(diffInSeconds / 60);
                return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.floor(diffInSeconds / 3600);
                return `${hours} hour${hours > 1 ? 's' : ''} ago`;
            } else if (diffInSeconds < 2592000) {
                const days = Math.floor(diffInSeconds / 86400);
                return `${days} day${days > 1 ? 's' : ''} ago`;
            } else {
                const months = Math.floor(diffInSeconds / 2592000);
                return `${months} month${months > 1 ? 's' : ''} ago`;
            }
        }

        // Logout function
        async function logout() {
            try {
                await emergencySystem.signOut();
                window.location.href = 'login.html';
            } catch (error) {
                console.error('Logout error:', error);
            }
        }

        // Handle window resize to ensure map works properly
        window.addEventListener('resize', () => {
            if (responderMap) {
                setTimeout(() => {
                    responderMap.invalidateSize();
                }, 100);
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (notificationChannel) {
                notificationChannel.unsubscribe();
            }
        });
    </script>
</body>
</html>